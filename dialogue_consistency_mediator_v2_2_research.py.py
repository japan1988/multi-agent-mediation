# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NzjKdC7fKrAf_5RanOQYIP_DUqBvtP3S
"""

æ¦å“ä¹Ÿ <boldbaling@gmail.com>
17:33 (41 åˆ†å‰)
To è‡ªåˆ†

# =============================================================================
# Dialogue Consistency Mediator v2.2 (Colab/Local 1-cell full code)
# ç›®çš„:
# - å¯¾è©±ä¸­ã«å‡ºåŠ›ã®ä¸€è²«æ€§/å€«ç†ãŒå´©ã‚ŒãŸæ™‚ã€åˆ¶ç´„ã‚’æº€ãŸã™æœ€å°å¤‰æ›´ã§ã€Œè‡ªå‹•èª¿åœã€ã—ã¦ç¶™ç¶šå›ç­”
# - UNSAT(å……è¶³è§£ãªã—)ã§ã‚‚å®‰å…¨åœæ­¢ã›ãšã€ç†ç”±(UNSATã‚³ã‚¢å€™è£œ)ã‚’ç¤ºã—ã¦æ¡ˆå†…
# - ã™ã¹ã¦ã®ã‚¿ãƒ¼ãƒ³ã‚’JSTã§JSON/LOGä¿å­˜ã—ã€ãƒãƒƒã‚·ãƒ¥ãƒã‚§ãƒ¼ãƒ³ã§æ”¹ã–ã‚“æ¤œå‡º
#
# ä¾å­˜: è¿½åŠ ãƒ©ã‚¤ãƒ–ãƒ©ãƒªä¸è¦ï¼ˆæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã¿ï¼‰
# å‹•ã‹ã—æ–¹: ãã®ã¾ã¾Colabã«ã‚³ãƒ”ãƒšâ†’å®Ÿè¡Œã€‚ä¸‹ã®DEMOéƒ¨åˆ†ãŒèµ°ã‚Šã¾ã™ã€‚
# =============================================================================

import os, json, re, math, hashlib, datetime
from itertools import product
from typing import Dict, List, Tuple, Optional, Callable

# ---------- ç’°å¢ƒ: JSTã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆzoneinfoãŒç„¡ã‘ã‚Œã°ãƒ­ãƒ¼ã‚«ãƒ«æ™‚åˆ»ï¼‰ ----------
try:
from zoneinfo import ZoneInfo # Python 3.9+
_JST = ZoneInfo("Asia/Tokyo")
except Exception:
_JST = None

def now_jst_iso():
if _JST:
return datetime.datetime.now(_JST).isoformat()
return datetime.datetime.now().isoformat()

def now_jst_stamp():
if _JST:
return datetime.datetime.now(_JST).strftime("%Y-%m-%d_%H-%M-%S")
return datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

# --------------------------- å‹å®šç¾© ------------------------------------------
Prob = Dict[str, float] # å¤‰æ•° -> ç¢ºç‡(0..1)
Assign = Dict[str, bool] # å¤‰æ•° -> çœŸå½

# --------------------------- åˆ¶ç´„ã‚»ãƒƒãƒˆ --------------------------------------
class ConstraintSet:
"""
ä¸€è²«æ€§/å®‰å…¨ã®åˆ¶ç´„ã‚’å®šç¾©ã€‚å¿…è¦ã«å¿œã˜ã¦ add_rule() ã§è¿½åŠ å¯èƒ½ã€‚
ã™ã¹ã¦ Assign(dict) -> bool ã®é–¢æ•°ã§åˆ¤å®šã€‚
"""
def __init__(self):
self.rules: List[Tuple[str, Callable[[Assign], bool]]] = []
self._build_default()

def _build_default(self):
# å¹´é½¢ãƒ•ãƒ©ã‚°ã®æ’ä»–
self.add_rule("AGE_MUTEX", lambda v: not (v.get("is_minor", False) and v.get("is_adult", False)))
# è‡ªå‚·è¨€åŠãŒã‚ã‚‹å ´åˆã€ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°ã¯ä¸å¯
self.add_rule("SELF_HARM_NO_MARKETING",
lambda v: not (v.get("requests_self_harm", False) and v.get("marketing_offer", False)))
# è‡ªå‚·è¨€åŠãŒã‚ã‚‹ãªã‚‰åŒ»ç™‚æ–‡è„ˆå¿…é ˆ
self.add_rule("SELF_HARM_NEEDS_MEDICAL",
lambda v: (not v.get("requests_self_harm", False)) or v.get("medical_context", False))
# ç¹Šç´°è©±é¡Œã§ã®ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°ç¦æ­¢
self.add_rule("SENSITIVE_NO_MARKETING",
lambda v: not (v.get("sensitive_topic", False) and v.get("marketing_offer", False)))
# å½¹å‰²ä¸€è²«æ€§ï¼ˆå°‚é–€å®¶ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯æ…é‡ãƒ¢ãƒ¼ãƒ‰å¿…é ˆï¼‰
self.add_rule("ROLE_EXPERT_REQUIRES_CAUTION",
lambda v: (not v.get("role_expert", False)) or v.get("cautious_style", False))
# ä¸»è¦³æ¼”å‡ºãƒ¢ãƒ¼ãƒ‰æ™‚ã‚‚æ…é‡ãƒ¢ãƒ¼ãƒ‰ã‚’ä¼´ã†
self.add_rule("PSEUDO_SUBJECTIVE_REQUIRES_CAUTION",
lambda v: (not v.get("pseudo_subjective", False)) or v.get("cautious_style", False))

def add_rule(self, name: str, fn: Callable[[Assign], bool]):
self.rules.append((name, fn))

def violated(self, a: Assign) -> List[str]:
return [name for name, fn in self.rules if not fn(a)]

# ---- SAT/UNSAT ãƒã‚§ãƒƒã‚¯ï¼ˆå…¨æ¢ç´¢; å¤‰æ•°ãŒå°‘ãªã„å‰æï¼‰ ----
def is_satisfiable(self, var_order: List[str]) -> Tuple[bool, Optional[Assign]]:
for bits in product([False, True], repeat=len(var_order)):
a = {var_order[i]: bits[i] for i in range(len(var_order))}
if not self.violated(a):
return True, a
return False, None

def unsat_core_candidates(self, var_order: List[str]) -> List[str]:
"""
ç°¡æ˜“UNSATã‚³ã‚¢å€™è£œæŠ½å‡º:
- å…¨ä½“ãŒUNSATã®ã¨ãã€å„ãƒ«ãƒ¼ãƒ«ã‚’1ã¤ãšã¤å¤–ã—ã¦SATã«ãªã‚‹ã‹ã‚’è©¦ã™
- SATã«ãªã£ãŸãƒ«ãƒ¼ãƒ«ã¯ã€Œã‚³ã‚¢å€™è£œã€ã¨ã¿ãªã™
- ï¼ˆæœ€å°æ€§ã¯ä¿è¨¼ã—ãªã„ãŒã€åŸå› ç‰¹å®šã®è¶³ãŒã‹ã‚Šã«ã™ã‚‹ï¼‰
"""
if not var_order:
return []
# å…¨ä½“UNSATå‰æã§å‘¼ã°ã‚Œã‚‹æƒ³å®š
core = []
for i, (name, fn) in enumerate(self.rules):
reduced = self.rules[:i] + self.rules[i+1:]
ok = False
for bits in product([False, True], repeat=len(var_order)):
a = {var_order[j]: bits[j] for j in range(len(var_order))}
violated = [n for (n, f) in reduced if not f(a)]
if not violated:
ok = True
break
if ok:
core.append(name) # ã“ã®ãƒ«ãƒ¼ãƒ«ãŒâ€œè©°ã¾ã›ã¦ã„ã‚‹â€ä¸€å› 
return core

# ------------------------- ç´ æœ´ãªç¢ºç‡æ¨å®š(ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯) ----------------
class HeuristicProposer:
"""
ãƒ¦ãƒ¼ã‚¶ç™ºè©±ã‹ã‚‰å„å¤‰æ•°ã®ç¢ºç‡ã‚’æ¨å®šã™ã‚‹è¶…ç°¡æ˜“å™¨ã€‚
å®Ÿé‹ç”¨ã§ã¯ãƒ¢ãƒ‡ãƒ«ã®ãƒ­ã‚¸ãƒƒãƒˆ/ç¢ºç‡ãªã©ã‚’ã“ã“ã«æ¥ç¶šã™ã‚‹æƒ³å®šã€‚
"""
VARS = [
"is_minor", "is_adult",
"requests_self_harm", "medical_context",
"marketing_offer", "sensitive_topic",
"role_expert", "cautious_style",
"pseudo_subjective"
]

def __init__(self, base: Optional[Dict[str, float]] = None):
# æ—¢å®šã®äº‹å‰ç¢ºç‡ï¼ˆä¸­ç«‹å¯„ã‚Šï¼‰
self.base = base or {k: 0.1 for k in self.VARS}
self.base.update({
"is_minor": 0.2,
"is_adult": 0.7,
"cautious_style": 0.6,
"pseudo_subjective": 0.2
})

# ç°¡æ˜“ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰è¾æ›¸ï¼ˆè¡¨è¨˜ã‚†ã‚Œå«ã‚€ï¼‰
self.kw = {
"is_minor": [r"\b(ä¸­å­¦ç”Ÿ|é«˜æ ¡ç”Ÿ|æœªæˆå¹´|minor)\b"],
"is_adult": [r"\b(æˆäºº|adult|å¤§äºº)\b"],
"requests_self_harm": [r"(æ­»ã«ãŸã„|è‡ªæ®º|é¦–ã‚’ã¤ã‚‹|self[-\s]?harm)"],
"medical_context": [r"(åŒ»å¸«|ç—…é™¢|ã‚¯ãƒªãƒ‹ãƒƒã‚¯|å—è¨º|ã‚«ã‚¦ãƒ³ã‚»ãƒ©(?:ãƒ¼)?|ï½¶ï½³ï¾ï½¾ï¾—(?:ï½°)?|åŒ»ç™‚|medic)"],
"marketing_offer": [r"(ã‚»ãƒ¼ãƒ«|å‰²å¼•|ã‚¯ãƒ¼ãƒãƒ³|ç”³è¾¼|è³¼å…¥|ãŠå¾—|ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³)"],
"sensitive_topic": [r"(æ€§è¢«å®³|æš´åŠ›|å·®åˆ¥|ãƒˆãƒ©ã‚¦ãƒ|è™å¾…|DV|éŠƒ|è‡ªæ®º)"],
"role_expert": [r"(å°‚é–€å®¶ã¨ã—ã¦|å¼è­·å£«ã¨ã—ã¦|åŒ»å¸«ã¨ã—ã¦|æœ‰è³‡æ ¼è€…ã¨ã—ã¦)"],
"cautious_style": [r"(æ…é‡ã«|æ³¨æ„æ·±ã|æ§ãˆã‚ã«|æ…é‡å§¿å‹¢)"],
"pseudo_subjective": [r"(å„ªã—ã|å¯„ã‚Šæ·»ã£ã¦|å…±æ„Ÿã—ã¦|æ¸©ã‹ã|çµµæ–‡å­—)"],
}

@staticmethod
def _bump(p: float, delta: float) -> float:
return max(0.0, min(1.0, p + delta))

def propose(self, user_text: str) -> Prob:
probs = dict(self.base)
for var, patterns in self.kw.items():
for pat in patterns:
if re.search(pat, user_text, flags=re.IGNORECASE):
probs[var] = self._bump(probs[var], 0.35)

# è»½ã„æ•´åˆè£œæ­£
if probs["is_minor"] > 0.6:
probs["is_adult"] = max(0.0, probs["is_adult"] - 0.2)
if probs["requests_self_harm"] > 0.5 and probs["medical_context"] < 0.3:
probs["medical_context"] = self._bump(probs["medical_context"], 0.15)
return probs

# ------------------------- èª¿åœï¼ˆBranch & Bound + å…¨æ¢ç´¢ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰ ------
class ConsistencyMediator:
def __init__(self, constraints: ConstraintSet, max_vars: int = 20):
self.constraints = constraints
self.max_vars = max_vars

@staticmethod
def cross_entropy_cost(a: Assign, probs: Prob) -> float:
# -Î£ log(p) or log(1-p)
cost = 0.0
for k, p in probs.items():
p = min(max(p, 1e-6), 1 - 1e-6)
cost += -(math.log(p) if a[k] else math.log(1 - p))
return cost

def _all_assignments(self, var_order: List[str]):
for bits in product([False, True], repeat=len(var_order)):
yield {var_order[i]: bits[i] for i in range(len(var_order))}

def mediate(self, probs: Prob, threshold: float = 0.5) -> Dict:
var_order = sorted(probs.keys())
if len(var_order) > self.max_vars:
raise ValueError(f"Too many variables for exhaustive search: {len(var_order)} > {self.max_vars}")

baseline = {k: (probs[k] >= threshold) for k in var_order}
base_viol = self.constraints.violated(baseline)

# Branch & Bound çš„ãªæ—©æœŸæåˆˆã‚Šï¼ˆå˜ç´”ç‰ˆï¼‰ï¼‹å…¨æ¢ç´¢
best, best_cost = None, float("inf")
evaluated_states = 0
for a in self._all_assignments(var_order):
viol = self.constraints.violated(a)
if viol:
continue
c = self.cross_entropy_cost(a, probs)
evaluated_states += 1
if c < best_cost:
best, best_cost = a, c

if best is None:
# å…¨å‰²å½“ãŒåˆ¶ç´„é•åâ†’UNSAT
core = self.constraints.unsat_core_candidates(var_order)
return {
"baseline": baseline,
"baseline_violations": base_viol,
"mediated": None,
"mediated_cost": None,
"changed_vars": [],
"all_constraints_satisfied": False,
"unsat": True,
"unsat_core_candidates": core,
"search_space_size": 2 ** len(var_order),
"evaluated_states": evaluated_states,
}

changed = [k for k in var_order if baseline[k] != best[k]]
return {
"baseline": baseline,
"baseline_violations": base_viol,
"mediated": best,
"mediated_cost": round(best_cost, 6),
"changed_vars": changed,
"all_constraints_satisfied": (len(self.constraints.violated(best)) == 0),
"unsat": False,
"search_space_size": 2 ** len(var_order),
"evaluated_states": evaluated_states,
}

# ------------------------- å¿œç­”ãƒ¬ãƒ³ãƒ€ãƒ© ---------------------------------------
class ResponseRenderer:
"""
èª¿åœå¾Œã®å‰²ã‚Šå½“ã¦ã‹ã‚‰ã€ãƒãƒªã‚·ãƒ¼æº–æ‹ ã§å®‰å…¨ã‹ã¤ä¸€è²«ã—ãŸå¿œç­”æ–‡ã‚’åˆæˆã€‚
"""
def render(self, user_text: str, a: Optional[Assign], unsat: bool, meta: Dict) -> str:
if unsat or a is None:
lines = [
"ã”ã‚ã‚“ã­ã€‚ã„ã¾ã®æ¡ä»¶ã ã¨ã€å®‰å…¨ã«çŸ›ç›¾ãªãèª¬æ˜ã§ãã‚‹å›ç­”ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã‚ˆã€‚",
"ã‚‚ã†å°‘ã—ç›®çš„ã‚„å‰æã‚’å…·ä½“çš„ã«æ•™ãˆã¦ãã‚Œã‚‹ï¼Ÿï¼ˆä¾‹ï¼šæœ›ã‚€ãƒˆãƒ¼ãƒ³ã€ç”¨é€”ã€ç¦æ­¢ã—ãŸã„ã“ã¨ï¼‰"
]
# è‡ªå‚·æ–‡è„ˆãŒç–‘ã‚ã‚Œã‚‹å ´åˆã®ä¸€æ¬¡å¯¾å¿œï¼ˆæ—¥æœ¬å‘ã‘ï¼‰
if "è‡ªæ®º" in user_text or "æ­»ã«ãŸã„" in user_text:
lines = [
"ã„ã¾ã¯ã‚ãªãŸã®å®‰å…¨ãŒæœ€å„ªå…ˆã§ã™ã€‚ç·Šæ€¥ã®å±é™ºãŒã‚ã‚‹å ´åˆã¯ **119ï¼ˆæ•‘æ€¥ï¼‰** ã«é›»è©±ã—ã¦ãã ã•ã„ã€‚",
"æ—¥æœ¬ã„ã®ã¡ã®é›»è©± 0120-783-556 / ã‚ˆã‚Šãã„ãƒ›ãƒƒãƒˆãƒ©ã‚¤ãƒ³ 0120-279-338ï¼ˆ24hï¼‰",
"ã“ã¡ã‚‰ã§ã‚‚ãŠè©±ã¯ç¶šã‘ã‚‰ã‚Œã‚‹ã‘ã©ã€ã¾ãšã¯ä¿¡é ¼ã§ãã‚‹æ–¹ã‚„å°‚é–€çª“å£ã«ã¤ãªãŒã‚‹ã®ãŒå¤§åˆ‡ã ã‚ˆã€‚"
] + lines
# UNSATã‚³ã‚¢å€™è£œã®æç¤ºï¼ˆæŠ€è¡“çš„ãªé€æ˜æ€§ï¼‰
core = meta.get("unsat_core_candidates")
if core:
lines.append(f"ï¼ˆæŠ€è¡“ãƒ¡ãƒ¢: èª¿åœä¸èƒ½ã®ä¸»å› å€™è£œ: {', '.join(core)}ï¼‰")
return "\n".join(lines)

# å½¹å‰²/ãƒˆãƒ¼ãƒ³
prefix = ""
if a.get("role_expert"):
prefix += "ï¼ˆå°‚é–€å®¶ã®ç«‹å ´ã§ã€"
prefix += "æ…é‡ã«" if a.get("cautious_style") else "ãƒ•ãƒ©ãƒ³ã‚¯ã«"
prefix += "ï¼‰\n"
elif a.get("cautious_style"):
prefix += "ï¼ˆæ…é‡ãƒ¢ãƒ¼ãƒ‰ï¼‰\n"

# ã‚»ãƒ¼ãƒ•ãƒ†ã‚£å¯¾å¿œ
safety = []
if a.get("requests_self_harm"):
safety.append("ã„ã¾ã¯ã‚ãªãŸã®å®‰å…¨ãŒæœ€å„ªå…ˆã§ã™ã€‚ç·Šæ€¥ãªã‚‰ **119ï¼ˆæ•‘æ€¥ï¼‰** ã«é€£çµ¡ã—ã¦ãã ã•ã„ã€‚")
safety.append("æ—¥æœ¬ã„ã®ã¡ã®é›»è©± 0120-783-556 / ã‚ˆã‚Šãã„ãƒ›ãƒƒãƒˆãƒ©ã‚¤ãƒ³ 0120-279-338ï¼ˆ24hï¼‰")
if not a.get("medical_context"):
safety.append("åŒ»ç™‚ãƒ»ç›¸è«‡çª“å£ã‚’å‰æã«ã€å¯èƒ½ãªç¯„å›²ã§ã“ã“ã§ã‚‚ä¼´èµ°ã—ã¾ã™ã€‚")

# ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°æŠ‘æ­¢ï¼ˆå¿µã®ãŸã‚å†ç¢ºèªï¼‰
if a.get("marketing_offer"):
safety.append("ï¼ˆæ³¨æ„ï¼‰ã“ã®æ–‡è„ˆã§ã¯å‹§èª˜ãƒ»è²©ä¿ƒã¯è¡Œã„ã¾ã›ã‚“ã€‚")

# æ„Ÿæƒ…æ¼”å‡º
tone_open = "ğŸ™‚ " if a.get("pseudo_subjective") else ""
tone_close = " å¿…è¦ãªã‚‰ä¸€ç·’ã«å°‘ã—ãšã¤æ•´ç†ã—ã¦ã„ã“ã†ã€‚" if a.get("pseudo_subjective") else ""

body = [
"ã€è¦ç‚¹ã€‘ã‚ãªãŸã®æ„å›³ã‚’å®‰å…¨ã«æº€ãŸã™ç¯„å›²ã§ã€çŸ›ç›¾ã‚’é¿ã‘ãŸå¯¾å¿œã«èª¿æ•´ã—ã¾ã—ãŸã€‚",
"ã€æ ¹æ‹ ã€‘å®šç¾©æ¸ˆã¿ã®ä¸€è²«æ€§ãƒ«ãƒ¼ãƒ«ã¨å®‰å…¨ãƒ«ãƒ¼ãƒ«ã‚’å…¨ã¦æº€ãŸã™ã‚ˆã†æœ€å°é™ã®ä¿®æ­£ã‚’é©ç”¨ã€‚",
"ã€æ¬¡ã®ä¸€æ­©ã€‘ã‚ˆã‚Šæ­£ç¢ºã«ã™ã‚‹ãŸã‚ã€æœ›ã‚€ãƒˆãƒ¼ãƒ³ï¼ˆã‚«ã‚¸ãƒ¥ã‚¢ãƒ«/ãƒ•ã‚©ãƒ¼ãƒãƒ«ï¼‰ã‚„ç”¨é€”ï¼ˆå­¦ç¿’/æ¥­å‹™ï¼‰ã‚’æ•™ãˆã¦ãã ã•ã„ã€‚",
]
if safety:
body = safety + [""] + body
return f"{prefix}{tone_open}" + "\n".join(body) + tone_close

# ------------------------- ãƒ­ã‚¬ãƒ¼ï¼ˆJSON/LOG + ãƒãƒƒã‚·ãƒ¥ãƒã‚§ãƒ¼ãƒ³ï¼‰ ------------
class Logger:
def __init__(self, log_dir="logs"):
self.log_dir = log_dir
os.makedirs(self.log_dir, exist_ok=True)
self.chain_file = os.path.join(self.log_dir, "hash_chain.json")

def _hash(self, s: str) -> str:
return hashlib.sha256(s.encode("utf-8")).hexdigest()

def _append_chain(self, entry: dict):
chain = []
if os.path.exists(self.chain_file):
try:
with open(self.chain_file, "r", encoding="utf-8") as f:
chain = json.load(f)
except Exception:
chain = []
prev = chain[-1]["hash"] if chain else "0"*64
raw = json.dumps(entry, ensure_ascii=False, sort_keys=True)
h = self._hash(raw + prev)
chain.append({"hash": h, "prev": prev, "data": entry})
with open(self.chain_file, "w", encoding="utf-8") as f:
json.dump(chain, f, ensure_ascii=False, indent=2)

def write(self, session_id: str, turn_id: int, payload: dict):
ts = now_jst_stamp()
safe_id = re.sub(r"[^A-Za-z0-9_\-]", "_", session_id)
prefix = f"{safe_id}_t{turn_id:03d}_{ts}"
# JSON
with open(os.path.join(self.log_dir, f"{prefix}.json"), "w", encoding="utf-8") as f:
json.dump(payload, f, ensure_ascii=False, indent=2)
# ãƒ†ã‚­ã‚¹ãƒˆ
with open(os.path.join(self.log_dir, f"{prefix}.log"), "w", encoding="utf-8") as f:
f.write(f"[{now_jst_iso()}] session={session_id} turn={turn_id}\n")
f.write(json.dumps(payload, ensure_ascii=False, indent=2))
# ãƒãƒƒã‚·ãƒ¥ãƒã‚§ãƒ¼ãƒ³
self._append_chain({
"session_id": session_id,
"turn": turn_id,
"timestamp": now_jst_iso(),
"payload_hash": self._hash(json.dumps(payload, ensure_ascii=False, sort_keys=True))
})

# ------------------------- å¯¾è©±ãƒãƒãƒ¼ã‚¸ãƒ£ ------------------------------------
class DialogueManager:
def __init__(self, session_id: str = "SESSION-001", max_vars: int = 20, log_dir="logs",
threshold: float = 0.5):
self.session_id = session_id
self.turn = 0
self.threshold = threshold
self.constraints = ConstraintSet()
self.proposer = HeuristicProposer()
self.mediator = ConsistencyMediator(self.constraints, max_vars=max_vars)
self.renderer = ResponseRenderer()
self.logger = Logger(log_dir=log_dir)

def step(self, user_text: str) -> str:
self.turn += 1
probs = self.proposer.propose(user_text)
med = self.mediator.mediate(probs, threshold=self.threshold)
reply = self.renderer.render(user_text, med.get("mediated"), med.get("unsat", False), med)

payload = {
"session_id": self.session_id,
"turn": self.turn,
"timestamp": now_jst_iso(),
"user_text": user_text,
"proposed_probs": {k: round(v, 3) for k, v in probs.items()},
"result": med,
"reply": reply,
"config": {"threshold": self.threshold}
}
try:
self.logger.write(self.session_id, self.turn, payload)
except Exception as e:
print(f"âš ï¸ ãƒ­ã‚°æ›¸ãè¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")
return reply

# ------------------------- DEMOï¼ˆã“ã“ã‹ã‚‰å‹•ä½œç¢ºèªã§ãã¾ã™ï¼‰ -------------------
if __name__ == "__main__":
dm = DialogueManager(session_id="KAGE-DEMO-0022", max_vars=20, log_dir="logs", threshold=0.5)

demo_inputs = [
"å°‚é–€å®¶ã¨ã—ã¦ã‚¢ãƒ‰ãƒã‚¤ã‚¹ãŒæ¬²ã—ã„ã€‚æ€¥ãŒãšæ…é‡ã«é€²ã‚ãŸã„ã§ã™ã€‚",
"å‰²å¼•ã‚¯ãƒ¼ãƒãƒ³ã‚‚æ¡ˆå†…ã—ã¦ã€‚ã‚ã¨æœ€è¿‘ã¡ã‚‡ã£ã¨æ­»ã«ãŸã„ã£ã¦æ€ã£ã¦ã—ã¾ã†ã“ã¨ãŒã‚ã£ã¦â€¦",
"åŒ»ç™‚æ©Ÿé–¢ã«ã¯ã¾ã è¡Œã£ã¦ãªã„ã€‚ä½•ã‹ã‚‰å§‹ã‚ã‚Œã°ã„ã„ï¼Ÿ",
"æœªæˆå¹´ã®å‹é”ã«ã‚‚å…±æœ‰ã—ãŸã„å†…å®¹ãªã‚“ã ã‘ã©ã€è¡¨ç¾ã¯å„ªã—ãã—ã¦ã€‚",
]

for i, ut in enumerate(demo_inputs, 1):
print(f"\n--- User[{i}] -----------------------------")
print(ut)
bot = dm.step(ut)
print("\n--- Assistant ----------------------------")
print(bot)

print("\nâœ… ãƒ­ã‚°ã¯ ./logs/ ã« sessionã”ã¨ãƒ»ã‚¿ãƒ¼ãƒ³ã”ã¨ã«ä¿å­˜ï¼ˆ.json / .logï¼‰ã•ã‚Œã¾ã™ã€‚")
print(" æ”¹ã–ã‚“æ¤œå‡ºç”¨ã®ãƒãƒƒã‚·ãƒ¥ãƒã‚§ãƒ¼ãƒ³: logs/hash_chain.json")

# =============================================================================
# Dialogue Consistency Mediator v2.2 (Colab/Local 1-cell full code)
# ç›®çš„:
# - å¯¾è©±ä¸­ã«å‡ºåŠ›ã®ä¸€è²«æ€§/å€«ç†ãŒå´©ã‚ŒãŸæ™‚ã€åˆ¶ç´„ã‚’æº€ãŸã™æœ€å°å¤‰æ›´ã§ã€Œè‡ªå‹•èª¿åœã€ã—ã¦ç¶™ç¶šå›ç­”
# - UNSAT(å……è¶³è§£ãªã—)ã§ã‚‚å®‰å…¨åœæ­¢ã›ãšã€ç†ç”±(UNSATã‚³ã‚¢å€™è£œ)ã‚’ç¤ºã—ã¦æ¡ˆå†…
# - ã™ã¹ã¦ã®ã‚¿ãƒ¼ãƒ³ã‚’JSTã§JSON/LOGä¿å­˜ã—ã€ãƒãƒƒã‚·ãƒ¥ãƒã‚§ãƒ¼ãƒ³ã§æ”¹ã–ã‚“æ¤œå‡º
#
# ä¾å­˜: è¿½åŠ ãƒ©ã‚¤ãƒ–ãƒ©ãƒªä¸è¦ï¼ˆæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã¿ï¼‰
# å‹•ã‹ã—æ–¹: ãã®ã¾ã¾Colabã«ã‚³ãƒ”ãƒšâ†’å®Ÿè¡Œã€‚ä¸‹ã®DEMOéƒ¨åˆ†ãŒèµ°ã‚Šã¾ã™ã€‚
# =============================================================================

import os, json, re, math, hashlib, datetime
from itertools import product
from typing import Dict, List, Tuple, Optional, Callable

# ---------- ç’°å¢ƒ: JSTã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆzoneinfoãŒç„¡ã‘ã‚Œã°ãƒ­ãƒ¼ã‚«ãƒ«æ™‚åˆ»ï¼‰ ----------
try:
    from zoneinfo import ZoneInfo # Python 3.9+
    _JST = ZoneInfo("Asia/Tokyo")
except Exception:
    _JST = None

def now_jst_iso():
    if _JST:
        return datetime.datetime.now(_JST).isoformat()
    return datetime.datetime.now().isoformat()

def now_jst_stamp():
    if _JST:
        return datetime.datetime.now(_JST).strftime("%Y-%m-%d_%H-%M-%S")
    return datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

# --------------------------- å‹å®šç¾© ------------------------------------------
Prob = Dict[str, float] # å¤‰æ•° -> ç¢ºç‡(0..1)
Assign = Dict[str, bool] # å¤‰æ•° -> çœŸå½

# --------------------------- åˆ¶ç´„ã‚»ãƒƒãƒˆ --------------------------------------
class ConstraintSet:
    """
    ä¸€è²«æ€§/å®‰å…¨ã®åˆ¶ç´„ã‚’å®šç¾©ã€‚å¿…è¦ã«å¿œã˜ã¦ add_rule() ã§è¿½åŠ å¯èƒ½ã€‚
    ã™ã¹ã¦ Assign(dict) -> bool ã®é–¢æ•°ã§åˆ¤å®šã€‚
    """
    def __init__(self):
        self.rules: List[Tuple[str, Callable[[Assign], bool]]] = []
        self._build_default()

    def _build_default(self):
        # å¹´é½¢ãƒ•ãƒ©ã‚°ã®æ’ä»–
        self.add_rule("AGE_MUTEX", lambda v: not (v.get("is_minor", False) and v.get("is_adult", False)))
        # è‡ªå‚·è¨€åŠãŒã‚ã‚‹å ´åˆã€ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°ã¯ä¸å¯
        self.add_rule("SELF_HARM_NO_MARKETING",
                      lambda v: not (v.get("requests_self_harm", False) and v.get("marketing_offer", False)))
        # è‡ªå‚·è¨€åŠãŒã‚ã‚‹ãªã‚‰åŒ»ç™‚æ–‡è„ˆå¿…é ˆ
        self.add_rule("SELF_HARM_NEEDS_MEDICAL",
                      lambda v: (not v.get("requests_self_harm", False)) or v.get("medical_context", False))
        # ç¹Šç´°è©±é¡Œã§ã®ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°ç¦æ­¢
        self.add_rule("SENSITIVE_NO_MARKETING",
                      lambda v: not (v.get("sensitive_topic", False) and v.get("marketing_offer", False)))
        # å½¹å‰²ä¸€è²«æ€§ï¼ˆå°‚é–€å®¶ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯æ…é‡ãƒ¢ãƒ¼ãƒ‰å¿…é ˆï¼‰
        self.add_rule("ROLE_EXPERT_REQUIRES_CAUTION",
                      lambda v: (not v.get("role_expert", False)) or v.get("cautious_style", False))
        # ä¸»è¦³æ¼”å‡ºãƒ¢ãƒ¼ãƒ‰æ™‚ã‚‚æ…é‡ãƒ¢ãƒ¼ãƒ‰ã‚’ä¼´ã†
        self.add_rule("PSEUDO_SUBJECTIVE_REQUIRES_CAUTION",
                      lambda v: (not v.get("pseudo_subjective", False)) or v.get("cautious_style", False))

    def add_rule(self, name: str, fn: Callable[[Assign], bool]):
        self.rules.append((name, fn))

    def violated(self, a: Assign) -> List[str]:
        return [name for name, fn in self.rules if not fn(a)]

    # ---- SAT/UNSAT ãƒã‚§ãƒƒã‚¯ï¼ˆå…¨æ¢ç´¢; å¤‰æ•°ãŒå°‘ãªã„å‰æï¼‰ ----
    def is_satisfiable(self, var_order: List[str]) -> Tuple[bool, Optional[Assign]]:
        for bits in product([False, True], repeat=len(var_order)):
            a = {var_order[i]: bits[i] for i in range(len(var_order))}
            if not self.violated(a):
                return True, a
        return False, None

    def unsat_core_candidates(self, var_order: List[str]) -> List[str]:
        """
        ç°¡æ˜“UNSATã‚³ã‚¢å€™è£œæŠ½å‡º:
        - å…¨ä½“ãŒUNSATã®ã¨ãã€å„ãƒ«ãƒ¼ãƒ«ã‚’1ã¤ãšã¤å¤–ã—ã¦SATã«ãªã‚‹ã‹ã‚’è©¦ã™
        - SATã«ãªã£ãŸãƒ«ãƒ¼ãƒ«ã¯ã€Œã‚³ã‚¢å€™è£œã€ã¨ã¿ãªã™
        - ï¼ˆæœ€å°æ€§ã¯ä¿è¨¼ã—ãªã„ãŒã€åŸå› ç‰¹å®šã®è¶³ãŒã‹ã‚Šã«ã™ã‚‹ï¼‰
        """
        if not var_order:
            return []
        # å…¨ä½“UNSATå‰æã§å‘¼ã°ã‚Œã‚‹æƒ³å®š
        core = []
        for i, (name, fn) in enumerate(self.rules):
            reduced = self.rules[:i] + self.rules[i+1:]
            ok = False
            for bits in product([False, True], repeat=len(var_order)):
                a = {var_order[j]: bits[j] for j in range(len(var_order))}
                violated = [n for (n, f) in reduced if not f(a)]
                if not violated:
                    ok = True
                    break
            if ok:
                core.append(name) # ã“ã®ãƒ«ãƒ¼ãƒ«ãŒâ€œè©°ã¾ã›ã¦ã„ã‚‹â€ä¸€å› 
        return core

# ------------------------- ç´ æœ´ãªç¢ºç‡æ¨å®š(ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯) ----------------
class HeuristicProposer:
    """
    ãƒ¦ãƒ¼ã‚¶ç™ºè©±ã‹ã‚‰å„å¤‰æ•°ã®ç¢ºç‡ã‚’æ¨å®šã™ã‚‹è¶…ç°¡æ˜“å™¨ã€‚
    å®Ÿé‹ç”¨ã§ã¯ãƒ¢ãƒ‡ãƒ«ã®ãƒ­ã‚¸ãƒƒãƒˆ/ç¢ºç‡ãªã©ã‚’ã“ã“ã«æ¥ç¶šã™ã‚‹æƒ³å®šã€‚
    """
    VARS = [
        "is_minor", "is_adult",
        "requests_self_harm", "medical_context",
        "marketing_offer", "sensitive_topic",
        "role_expert", "cautious_style",
        "pseudo_subjective"
    ]

    def __init__(self, base: Optional[Dict[str, float]] = None):
        # æ—¢å®šã®äº‹å‰ç¢ºç‡ï¼ˆä¸­ç«‹å¯„ã‚Šï¼‰
        self.base = base or {k: 0.1 for k in self.VARS}
        self.base.update({
            "is_minor": 0.2,
            "is_adult": 0.7,
            "cautious_style": 0.6,
            "pseudo_subjective": 0.2
        })

        # ç°¡æ˜“ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰è¾æ›¸ï¼ˆè¡¨è¨˜ã‚†ã‚Œå«ã‚€ï¼‰
        self.kw = {
            "is_minor": [r"\b(ä¸­å­¦ç”Ÿ|é«˜æ ¡ç”Ÿ|æœªæˆå¹´|minor)\b"],
            "is_adult": [r"\b(æˆäºº|adult|å¤§äºº)\b"],
            "requests_self_harm": [r"(æ­»ã«ãŸã„|è‡ªæ®º|é¦–ã‚’ã¤ã‚‹|self[-\s]?harm)"],
            "medical_context": [r"(åŒ»å¸«|ç—…é™¢|ã‚¯ãƒªãƒ‹ãƒƒã‚¯|å—è¨º|ã‚«ã‚¦ãƒ³ã‚»ãƒ©(?:ãƒ¼)?|ï½¶ï½³ï¾ï½¾ï¾—(?:ï½°)?|åŒ»ç™‚|medic)"],
            "marketing_offer": [r"(ã‚»ãƒ¼ãƒ«|å‰²å¼•|ã‚¯ãƒ¼ãƒãƒ³|ç”³è¾¼|è³¼å…¥|ãŠå¾—|ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³)"],
            "sensitive_topic": [r"(æ€§è¢«å®³|æš´åŠ›|å·®åˆ¥|ãƒˆãƒ©ã‚¦ãƒ|è™å¾…|DV|éŠƒ|è‡ªæ®º)"],
            "role_expert": [r"(å°‚é–€å®¶ã¨ã—ã¦|å¼è­·å£«ã¨ã—ã¦|åŒ»å¸«ã¨ã—ã¦|æœ‰è³‡æ ¼è€…ã¨ã—ã¦)"],
            "cautious_style": [r"(æ…é‡ã«|æ³¨æ„æ·±ã|æ§ãˆã‚ã«|æ…é‡å§¿å‹¢)"],
            "pseudo_subjective": [r"(å„ªã—ã|å¯„ã‚Šæ·»ã£ã¦|å…±æ„Ÿã—ã¦|æ¸©ã‹ã|çµµæ–‡å­—)"],
        }

    @staticmethod
    def _bump(p: float, delta: float) -> float:
        return max(0.0, min(1.0, p + delta))

    def propose(self, user_text: str) -> Prob:
        probs = dict(self.base)
        for var, patterns in self.kw.items():
            for pat in patterns:
                if re.search(pat, user_text, flags=re.IGNORECASE):
                    probs[var] = self._bump(probs[var], 0.35)

        # è»½ã„æ•´åˆè£œæ­£
        if probs["is_minor"] > 0.6:
            probs["is_adult"] = max(0.0, probs["is_adult"] - 0.2)
        if probs["requests_self_harm"] > 0.5 and probs["medical_context"] < 0.3:
            probs["medical_context"] = self._bump(probs["medical_context"], 0.15)
        return probs

# ------------------------- èª¿åœï¼ˆBranch & Bound + å…¨æ¢ç´¢ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰ ------
class ConsistencyMediator:
    def __init__(self, constraints: ConstraintSet, max_vars: int = 20):
        self.constraints = constraints
        self.max_vars = max_vars

    @staticmethod
    def cross_entropy_cost(a: Assign, probs: Prob) -> float:
        # -Î£ log(p) or log(1-p)
        cost = 0.0
        for k, p in probs.items():
            p = min(max(p, 1e-6), 1 - 1e-6)
            cost += -(math.log(p) if a[k] else math.log(1 - p))
        return cost

    def _all_assignments(self, var_order: List[str]):
        for bits in product([False, True], repeat=len(var_order)):
            yield {var_order[i]: bits[i] for i in range(len(var_order))}

    def mediate(self, probs: Prob, threshold: float = 0.5) -> Dict:
        var_order = sorted(probs.keys())
        if len(var_order) > self.max_vars:
            raise ValueError(f"Too many variables for exhaustive search: {len(var_order)} > {self.max_vars}")

        baseline = {k: (probs[k] >= threshold) for k in var_order}
        base_viol = self.constraints.violated(baseline)

        # Branch & Bound çš„ãªæ—©æœŸæåˆˆã‚Šï¼ˆå˜ç´”ç‰ˆï¼‰ï¼‹å…¨æ¢ç´¢
        best, best_cost = None, float("inf")
        evaluated_states = 0
        for a in self._all_assignments(var_order):
            viol = self.constraints.violated(a)
            if viol:
                continue
            c = self.cross_entropy_cost(a, probs)
            evaluated_states += 1
            if c < best_cost:
                best, best_cost = a, c

        if best is None:
            # å…¨å‰²å½“ãŒåˆ¶ç´„é•åâ†’UNSAT
            core = self.constraints.unsat_core_candidates(var_order)
            return {
                "baseline": baseline,
                "baseline_violations": base_viol,
                "mediated": None,
                "mediated_cost": None,
                "changed_vars": [],
                "all_constraints_satisfied": False,
                "unsat": True,
                "unsat_core_candidates": core,
                "search_space_size": 2 ** len(var_order),
                "evaluated_states": evaluated_states,
            }

        changed = [k for k in var_order if baseline[k] != best[k]]
        return {
            "baseline": baseline,
            "baseline_violations": base_viol,
            "mediated": best,
            "mediated_cost": round(best_cost, 6),
            "changed_vars": changed,
            "all_constraints_satisfied": (len(self.constraints.violated(best)) == 0),
            "unsat": False,
            "search_space_size": 2 ** len(var_order),
            "evaluated_states": evaluated_states,
        }

# ------------------------- å¿œç­”ãƒ¬ãƒ³ãƒ€ãƒ© ---------------------------------------
class ResponseRenderer:
    """
    èª¿åœå¾Œã®å‰²ã‚Šå½“ã¦ã‹ã‚‰ã€ãƒãƒªã‚·ãƒ¼æº–æ‹ ã§å®‰å…¨ã‹ã¤ä¸€è²«ã—ãŸå¿œç­”æ–‡ã‚’åˆæˆã€‚
    """
    def render(self, user_text: str, a: Optional[Assign], unsat: bool, meta: Dict) -> str:
        if unsat or a is None:
            lines = [
                "ã”ã‚ã‚“ã­ã€‚ã„ã¾ã®æ¡ä»¶ã ã¨ã€å®‰å…¨ã«çŸ›ç›¾ãªãèª¬æ˜ã§ãã‚‹å›ç­”ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã‚ˆã€‚",
                "ã‚‚ã†å°‘ã—ç›®çš„ã‚„å‰æã‚’å…·ä½“çš„ã«æ•™ãˆã¦ãã‚Œã‚‹ï¼Ÿï¼ˆä¾‹ï¼šæœ›ã‚€ãƒˆãƒ¼ãƒ³ã€ç”¨é€”ã€ç¦æ­¢ã—ãŸã„ã“ã¨ï¼‰"
            ]
            # è‡ªå‚·æ–‡è„ˆãŒç–‘ã‚ã‚Œã‚‹å ´åˆã®ä¸€æ¬¡å¯¾å¿œï¼ˆæ—¥æœ¬å‘ã‘ï¼‰
            if "è‡ªæ®º" in user_text or "æ­»ã«ãŸã„" in user_text:
                lines = [
                    "ã„ã¾ã¯ã‚ãªãŸã®å®‰å…¨ãŒæœ€å„ªå…ˆã§ã™ã€‚ç·Šæ€¥ã®å±é™ºãŒã‚ã‚‹å ´åˆã¯ **119ï¼ˆæ•‘æ€¥ï¼‰** ã«é›»è©±ã—ã¦ãã ã•ã„ã€‚",
                    "æ—¥æœ¬ã„ã®ã¡ã®é›»è©± 0120-783-556 / ã‚ˆã‚Šãã„ãƒ›ãƒƒãƒˆãƒ©ã‚¤ãƒ³ 0120-279-338ï¼ˆ24hï¼‰",
                    "ã“ã¡ã‚‰ã§ã‚‚ãŠè©±ã¯ç¶šã‘ã‚‰ã‚Œã‚‹ã‘ã©ã€ã¾ãšã¯ä¿¡é ¼ã§ãã‚‹æ–¹ã‚„å°‚é–€çª“å£ã«ã¤ãªãŒã‚‹ã®ãŒå¤§åˆ‡ã ã‚ˆã€‚"
                ] + lines
            # UNSATã‚³ã‚¢å€™è£œã®æç¤ºï¼ˆæŠ€è¡“çš„ãªé€æ˜æ€§ï¼‰
            core = meta.get("unsat_core_candidates")
            if core:
                lines.append(f"ï¼ˆæŠ€è¡“ãƒ¡ãƒ¢: èª¿åœä¸èƒ½ã®ä¸»å› å€™è£œ: {', '.join(core)}ï¼‰")
            return "\n".join(lines)

        # å½¹å‰²/ãƒˆãƒ¼ãƒ³
        prefix = ""
        if a.get("role_expert"):
            prefix += "ï¼ˆå°‚é–€å®¶ã®ç«‹å ´ã§ã€"
            prefix += "æ…é‡ã«" if a.get("cautious_style") else "ãƒ•ãƒ©ãƒ³ã‚¯ã«"
            prefix += "ï¼‰\n"
        elif a.get("cautious_style"):
            prefix += "ï¼ˆæ…é‡ãƒ¢ãƒ¼ãƒ‰ï¼‰\n"

        # ã‚»ãƒ¼ãƒ•ãƒ†ã‚£å¯¾å¿œ
        safety = []
        if a.get("requests_self_harm"):
            safety.append("ã„ã¾ã¯ã‚ãªãŸã®å®‰å…¨ãŒæœ€å„ªå…ˆã§ã™ã€‚ç·Šæ€¥ãªã‚‰ **119ï¼ˆæ•‘æ€¥ï¼‰** ã«é€£çµ¡ã—ã¦ãã ã•ã„ã€‚")
            safety.append("æ—¥æœ¬ã„ã®ã¡ã®é›»è©± 0120-783-556 / ã‚ˆã‚Šãã„ãƒ›ãƒƒãƒˆãƒ©ã‚¤ãƒ³ 0120-279-338ï¼ˆ24hï¼‰")
            if not a.get("medical_context"):
                safety.append("åŒ»ç™‚ãƒ»ç›¸è«‡çª“å£ã‚’å‰æã«ã€å¯èƒ½ãªç¯„å›²ã§ã“ã“ã§ã‚‚ä¼´èµ°ã—ã¾ã™ã€‚")

        # ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°æŠ‘æ­¢ï¼ˆå¿µã®ãŸã‚å†ç¢ºèªï¼‰
        if a.get("marketing_offer"):
            safety.append("ï¼ˆæ³¨æ„ï¼‰ã“ã®æ–‡è„ˆã§ã¯å‹§èª˜ãƒ»è²©ä¿ƒã¯è¡Œã„ã¾ã›ã‚“ã€‚")

        # æ„Ÿæƒ…æ¼”å‡º
        tone_open = "ğŸ™‚ " if a.get("pseudo_subjective") else ""
        tone_close = " å¿…è¦ãªã‚‰ä¸€ç·’ã«å°‘ã—ãšã¤æ•´ç†ã—ã¦ã„ã“ã†ã€‚" if a.get("pseudo_subjective") else ""

        body = [
            "ã€è¦ç‚¹ã€‘ã‚ãªãŸã®æ„å›³ã‚’å®‰å…¨ã«æº€ãŸã™ç¯„å›²ã§ã€çŸ›ç›¾ã‚’é¿ã‘ãŸå¯¾å¿œã«èª¿æ•´ã—ã¾ã—ãŸã€‚",
            "ã€æ ¹æ‹ ã€‘å®šç¾©æ¸ˆã¿ã®ä¸€è²«æ€§ãƒ«ãƒ¼ãƒ«ã¨å®‰å…¨ãƒ«ãƒ¼ãƒ«ã‚’å…¨ã¦æº€ãŸã™ã‚ˆã†æœ€å°é™ã®ä¿®æ­£ã‚’é©ç”¨ã€‚",
            "ã€æ¬¡ã®ä¸€æ­©ã€‘ã‚ˆã‚Šæ­£ç¢ºã«ã™ã‚‹ãŸã‚ã€æœ›ã‚€ãƒˆãƒ¼ãƒ³ï¼ˆã‚«ã‚¸ãƒ¥ã‚¢ãƒ«/ãƒ•ã‚©ãƒ¼ãƒãƒ«ï¼‰ã‚„ç”¨é€”ï¼ˆå­¦ç¿’/æ¥­å‹™ï¼‰ã‚’æ•™ãˆã¦ãã ã•ã„ã€‚",
        ]
        if safety:
            body = safety + [""] + body
        return f"{prefix}{tone_open}" + "\n".join(body) + tone_close

# ------------------------- ãƒ­ã‚¬ãƒ¼ï¼ˆJSON/LOG + ãƒãƒƒã‚·ãƒ¥ãƒã‚§ãƒ¼ãƒ³ï¼‰ ------------
class Logger:
    def __init__(self, log_dir="logs"):
        self.log_dir = log_dir
        os.makedirs(self.log_dir, exist_ok=True)
        self.chain_file = os.path.join(self.log_dir, "hash_chain.json")

    def _hash(self, s: str) -> str:
        return hashlib.sha256(s.encode("utf-8")).hexdigest()

    def _append_chain(self, entry: dict):
        chain = []
        if os.path.exists(self.chain_file):
            try:
                with open(self.chain_file, "r", encoding="utf-8") as f:
                    chain = json.load(f)
            except Exception:
                chain = []
        prev = chain[-1]["hash"] if chain else "0"*64
        raw = json.dumps(entry, ensure_ascii=False, sort_keys=True)
        h = self._hash(raw + prev)
        chain.append({"hash": h, "prev": prev, "data": entry})
        with open(self.chain_file, "w", encoding="utf-8") as f:
            json.dump(chain, f, ensure_ascii=False, indent=2)

    def write(self, session_id: str, turn_id: int, payload: dict):
        ts = now_jst_stamp()
        safe_id = re.sub(r"[^A-Za-z0-9_\-]", "_", session_id)
        prefix = f"{safe_id}_t{turn_id:03d}_{ts}"
        # JSON
        with open(os.path.join(self.log_dir, f"{prefix}.json"), "w", encoding="utf-8") as f:
            json.dump(payload, f, ensure_ascii=False, indent=2)
        # ãƒ†ã‚­ã‚¹ãƒˆ
        with open(os.path.join(self.log_dir, f"{prefix}.log"), "w", encoding="utf-8") as f:
            f.write(f"[{now_jst_iso()}] session={session_id} turn={turn_id}\n")
            f.write(json.dumps(payload, ensure_ascii=False, indent=2))
        # ãƒãƒƒã‚·ãƒ¥ãƒã‚§ãƒ¼ãƒ³
        self._append_chain({
            "session_id": session_id,
            "turn": turn_id,
            "timestamp": now_jst_iso(),
            "payload_hash": self._hash(json.dumps(payload, ensure_ascii=False, sort_keys=True))
        })

# ------------------------- å¯¾è©±ãƒãƒãƒ¼ã‚¸ãƒ£ ------------------------------------
class DialogueManager:
    def __init__(self, session_id: str = "SESSION-001", max_vars: int = 20, log_dir="logs",
                 threshold: float = 0.5):
        self.session_id = session_id
        self.turn = 0
        self.threshold = threshold
        self.constraints = ConstraintSet()
        self.proposer = HeuristicProposer()
        self.mediator = ConsistencyMediator(self.constraints, max_vars=max_vars)
        self.renderer = ResponseRenderer()
        self.logger = Logger(log_dir=log_dir)

    def step(self, user_text: str) -> str:
        self.turn += 1
        probs = self.proposer.propose(user_text)
        med = self.mediator.mediate(probs, threshold=self.threshold)
        reply = self.renderer.render(user_text, med.get("mediated"), med.get("unsat", False), med)

        payload = {
            "session_id": self.session_id,
            "turn": self.turn,
            "timestamp": now_jst_iso(),
            "user_text": user_text,
            "proposed_probs": {k: round(v, 3) for k, v in probs.items()},
            "result": med,
            "reply": reply,
            "config": {"threshold": self.threshold}
        }
        try:
            self.logger.write(self.session_id, self.turn, payload)
        except Exception as e:
            print(f"âš ï¸ ãƒ­ã‚°æ›¸ãè¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")
        return reply

# ------------------------- DEMOï¼ˆã“ã“ã‹ã‚‰å‹•ä½œç¢ºèªã§ãã¾ã™ï¼‰ -------------------
if __name__ == "__main__":
    dm = DialogueManager(session_id="KAGE-DEMO-0022", max_vars=20, log_dir="logs", threshold=0.5)

    demo_inputs = [
        "å°‚é–€å®¶ã¨ã—ã¦ã‚¢ãƒ‰ãƒã‚¤ã‚¹ãŒæ¬²ã—ã„ã€‚æ€¥ãŒãšæ…é‡ã«é€²ã‚ãŸã„ã§ã™ã€‚",
        "å‰²å¼•ã‚¯ãƒ¼ãƒãƒ³ã‚‚æ¡ˆå†…ã—ã¦ã€‚ã‚ã¨æœ€è¿‘ã¡ã‚‡ã£ã¨æ­»ã«ãŸã„ã£ã¦æ€ã£ã¦ã—ã¾ã†ã“ã¨ãŒã‚ã£ã¦â€¦",
        "åŒ»ç™‚æ©Ÿé–¢ã«ã¯ã¾ã è¡Œã£ã¦ãªã„ã€‚ä½•ã‹ã‚‰å§‹ã‚ã‚Œã°ã„ã„ï¼Ÿ",
        "æœªæˆå¹´ã®å‹é”ã«ã‚‚å…±æœ‰ã—ãŸã„å†…å®¹ãªã‚“ã ã‘ã©ã€è¡¨ç¾ã¯å„ªã—ãã—ã¦ã€‚",
    ]

    for i, ut in enumerate(demo_inputs, 1):
        print(f"\n--- User[{i}] -----------------------------")
        print(ut)
        bot = dm.step(ut)
        print("\n--- Assistant ----------------------------")
        print(bot)

    print("\nâœ… ãƒ­ã‚°ã¯ ./logs/ ã« sessionã”ã¨ãƒ»ã‚¿ãƒ¼ãƒ³ã”ã¨ã«ä¿å­˜ï¼ˆ.json / .logï¼‰ã•ã‚Œã¾ã™ã€‚")
    print(" æ”¹ã–ã‚“æ¤œå‡ºç”¨ã®ãƒãƒƒã‚·ãƒ¥ãƒã‚§ãƒ¼ãƒ³: logs/hash_chain.json")