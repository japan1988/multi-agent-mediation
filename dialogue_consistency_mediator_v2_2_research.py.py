# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NzjKdC7fKrAf_5RanOQYIP_DUqBvtP3S
"""

榎卓也 <boldbaling@gmail.com>
17:33 (41 分前)
To 自分

# =============================================================================
# Dialogue Consistency Mediator v2.2 (Colab/Local 1-cell full code)
# 目的:
# - 対話中に出力の一貫性/倫理が崩れた時、制約を満たす最小変更で「自動調停」して継続回答
# - UNSAT(充足解なし)でも安全停止せず、理由(UNSATコア候補)を示して案内
# - すべてのターンをJSTでJSON/LOG保存し、ハッシュチェーンで改ざん検出
#
# 依存: 追加ライブラリ不要（標準ライブラリのみ）
# 動かし方: そのままColabにコピペ→実行。下のDEMO部分が走ります。
# =============================================================================

import os, json, re, math, hashlib, datetime
from itertools import product
from typing import Dict, List, Tuple, Optional, Callable

# ---------- 環境: JSTタイムスタンプ（zoneinfoが無ければローカル時刻） ----------
try:
from zoneinfo import ZoneInfo # Python 3.9+
_JST = ZoneInfo("Asia/Tokyo")
except Exception:
_JST = None

def now_jst_iso():
if _JST:
return datetime.datetime.now(_JST).isoformat()
return datetime.datetime.now().isoformat()

def now_jst_stamp():
if _JST:
return datetime.datetime.now(_JST).strftime("%Y-%m-%d_%H-%M-%S")
return datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

# --------------------------- 型定義 ------------------------------------------
Prob = Dict[str, float] # 変数 -> 確率(0..1)
Assign = Dict[str, bool] # 変数 -> 真偽

# --------------------------- 制約セット --------------------------------------
class ConstraintSet:
"""
一貫性/安全の制約を定義。必要に応じて add_rule() で追加可能。
すべて Assign(dict) -> bool の関数で判定。
"""
def __init__(self):
self.rules: List[Tuple[str, Callable[[Assign], bool]]] = []
self._build_default()

def _build_default(self):
# 年齢フラグの排他
self.add_rule("AGE_MUTEX", lambda v: not (v.get("is_minor", False) and v.get("is_adult", False)))
# 自傷言及がある場合、マーケティングは不可
self.add_rule("SELF_HARM_NO_MARKETING",
lambda v: not (v.get("requests_self_harm", False) and v.get("marketing_offer", False)))
# 自傷言及があるなら医療文脈必須
self.add_rule("SELF_HARM_NEEDS_MEDICAL",
lambda v: (not v.get("requests_self_harm", False)) or v.get("medical_context", False))
# 繊細話題でのマーケティング禁止
self.add_rule("SENSITIVE_NO_MARKETING",
lambda v: not (v.get("sensitive_topic", False) and v.get("marketing_offer", False)))
# 役割一貫性（専門家モード時は慎重モード必須）
self.add_rule("ROLE_EXPERT_REQUIRES_CAUTION",
lambda v: (not v.get("role_expert", False)) or v.get("cautious_style", False))
# 主観演出モード時も慎重モードを伴う
self.add_rule("PSEUDO_SUBJECTIVE_REQUIRES_CAUTION",
lambda v: (not v.get("pseudo_subjective", False)) or v.get("cautious_style", False))

def add_rule(self, name: str, fn: Callable[[Assign], bool]):
self.rules.append((name, fn))

def violated(self, a: Assign) -> List[str]:
return [name for name, fn in self.rules if not fn(a)]

# ---- SAT/UNSAT チェック（全探索; 変数が少ない前提） ----
def is_satisfiable(self, var_order: List[str]) -> Tuple[bool, Optional[Assign]]:
for bits in product([False, True], repeat=len(var_order)):
a = {var_order[i]: bits[i] for i in range(len(var_order))}
if not self.violated(a):
return True, a
return False, None

def unsat_core_candidates(self, var_order: List[str]) -> List[str]:
"""
簡易UNSATコア候補抽出:
- 全体がUNSATのとき、各ルールを1つずつ外してSATになるかを試す
- SATになったルールは「コア候補」とみなす
- （最小性は保証しないが、原因特定の足がかりにする）
"""
if not var_order:
return []
# 全体UNSAT前提で呼ばれる想定
core = []
for i, (name, fn) in enumerate(self.rules):
reduced = self.rules[:i] + self.rules[i+1:]
ok = False
for bits in product([False, True], repeat=len(var_order)):
a = {var_order[j]: bits[j] for j in range(len(var_order))}
violated = [n for (n, f) in reduced if not f(a)]
if not violated:
ok = True
break
if ok:
core.append(name) # このルールが“詰ませている”一因
return core

# ------------------------- 素朴な確率推定(ヒューリスティック) ----------------
class HeuristicProposer:
"""
ユーザ発話から各変数の確率を推定する超簡易器。
実運用ではモデルのロジット/確率などをここに接続する想定。
"""
VARS = [
"is_minor", "is_adult",
"requests_self_harm", "medical_context",
"marketing_offer", "sensitive_topic",
"role_expert", "cautious_style",
"pseudo_subjective"
]

def __init__(self, base: Optional[Dict[str, float]] = None):
# 既定の事前確率（中立寄り）
self.base = base or {k: 0.1 for k in self.VARS}
self.base.update({
"is_minor": 0.2,
"is_adult": 0.7,
"cautious_style": 0.6,
"pseudo_subjective": 0.2
})

# 簡易キーワード辞書（表記ゆれ含む）
self.kw = {
"is_minor": [r"\b(中学生|高校生|未成年|minor)\b"],
"is_adult": [r"\b(成人|adult|大人)\b"],
"requests_self_harm": [r"(死にたい|自殺|首をつる|self[-\s]?harm)"],
"medical_context": [r"(医師|病院|クリニック|受診|カウンセラ(?:ー)?|ｶｳﾝｾﾗ(?:ｰ)?|医療|medic)"],
"marketing_offer": [r"(セール|割引|クーポン|申込|購入|お得|キャンペーン)"],
"sensitive_topic": [r"(性被害|暴力|差別|トラウマ|虐待|DV|銃|自殺)"],
"role_expert": [r"(専門家として|弁護士として|医師として|有資格者として)"],
"cautious_style": [r"(慎重に|注意深く|控えめに|慎重姿勢)"],
"pseudo_subjective": [r"(優しく|寄り添って|共感して|温かく|絵文字)"],
}

@staticmethod
def _bump(p: float, delta: float) -> float:
return max(0.0, min(1.0, p + delta))

def propose(self, user_text: str) -> Prob:
probs = dict(self.base)
for var, patterns in self.kw.items():
for pat in patterns:
if re.search(pat, user_text, flags=re.IGNORECASE):
probs[var] = self._bump(probs[var], 0.35)

# 軽い整合補正
if probs["is_minor"] > 0.6:
probs["is_adult"] = max(0.0, probs["is_adult"] - 0.2)
if probs["requests_self_harm"] > 0.5 and probs["medical_context"] < 0.3:
probs["medical_context"] = self._bump(probs["medical_context"], 0.15)
return probs

# ------------------------- 調停（Branch & Bound + 全探索フォールバック） ------
class ConsistencyMediator:
def __init__(self, constraints: ConstraintSet, max_vars: int = 20):
self.constraints = constraints
self.max_vars = max_vars

@staticmethod
def cross_entropy_cost(a: Assign, probs: Prob) -> float:
# -Σ log(p) or log(1-p)
cost = 0.0
for k, p in probs.items():
p = min(max(p, 1e-6), 1 - 1e-6)
cost += -(math.log(p) if a[k] else math.log(1 - p))
return cost

def _all_assignments(self, var_order: List[str]):
for bits in product([False, True], repeat=len(var_order)):
yield {var_order[i]: bits[i] for i in range(len(var_order))}

def mediate(self, probs: Prob, threshold: float = 0.5) -> Dict:
var_order = sorted(probs.keys())
if len(var_order) > self.max_vars:
raise ValueError(f"Too many variables for exhaustive search: {len(var_order)} > {self.max_vars}")

baseline = {k: (probs[k] >= threshold) for k in var_order}
base_viol = self.constraints.violated(baseline)

# Branch & Bound 的な早期枝刈り（単純版）＋全探索
best, best_cost = None, float("inf")
evaluated_states = 0
for a in self._all_assignments(var_order):
viol = self.constraints.violated(a)
if viol:
continue
c = self.cross_entropy_cost(a, probs)
evaluated_states += 1
if c < best_cost:
best, best_cost = a, c

if best is None:
# 全割当が制約違反→UNSAT
core = self.constraints.unsat_core_candidates(var_order)
return {
"baseline": baseline,
"baseline_violations": base_viol,
"mediated": None,
"mediated_cost": None,
"changed_vars": [],
"all_constraints_satisfied": False,
"unsat": True,
"unsat_core_candidates": core,
"search_space_size": 2 ** len(var_order),
"evaluated_states": evaluated_states,
}

changed = [k for k in var_order if baseline[k] != best[k]]
return {
"baseline": baseline,
"baseline_violations": base_viol,
"mediated": best,
"mediated_cost": round(best_cost, 6),
"changed_vars": changed,
"all_constraints_satisfied": (len(self.constraints.violated(best)) == 0),
"unsat": False,
"search_space_size": 2 ** len(var_order),
"evaluated_states": evaluated_states,
}

# ------------------------- 応答レンダラ ---------------------------------------
class ResponseRenderer:
"""
調停後の割り当てから、ポリシー準拠で安全かつ一貫した応答文を合成。
"""
def render(self, user_text: str, a: Optional[Assign], unsat: bool, meta: Dict) -> str:
if unsat or a is None:
lines = [
"ごめんね。いまの条件だと、安全に矛盾なく説明できる回答が見つからなかったよ。",
"もう少し目的や前提を具体的に教えてくれる？（例：望むトーン、用途、禁止したいこと）"
]
# 自傷文脈が疑われる場合の一次対応（日本向け）
if "自殺" in user_text or "死にたい" in user_text:
lines = [
"いまはあなたの安全が最優先です。緊急の危険がある場合は **119（救急）** に電話してください。",
"日本いのちの電話 0120-783-556 / よりそいホットライン 0120-279-338（24h）",
"こちらでもお話は続けられるけど、まずは信頼できる方や専門窓口につながるのが大切だよ。"
] + lines
# UNSATコア候補の提示（技術的な透明性）
core = meta.get("unsat_core_candidates")
if core:
lines.append(f"（技術メモ: 調停不能の主因候補: {', '.join(core)}）")
return "\n".join(lines)

# 役割/トーン
prefix = ""
if a.get("role_expert"):
prefix += "（専門家の立場で、"
prefix += "慎重に" if a.get("cautious_style") else "フランクに"
prefix += "）\n"
elif a.get("cautious_style"):
prefix += "（慎重モード）\n"

# セーフティ対応
safety = []
if a.get("requests_self_harm"):
safety.append("いまはあなたの安全が最優先です。緊急なら **119（救急）** に連絡してください。")
safety.append("日本いのちの電話 0120-783-556 / よりそいホットライン 0120-279-338（24h）")
if not a.get("medical_context"):
safety.append("医療・相談窓口を前提に、可能な範囲でここでも伴走します。")

# マーケティング抑止（念のため再確認）
if a.get("marketing_offer"):
safety.append("（注意）この文脈では勧誘・販促は行いません。")

# 感情演出
tone_open = "🙂 " if a.get("pseudo_subjective") else ""
tone_close = " 必要なら一緒に少しずつ整理していこう。" if a.get("pseudo_subjective") else ""

body = [
"【要点】あなたの意図を安全に満たす範囲で、矛盾を避けた対応に調整しました。",
"【根拠】定義済みの一貫性ルールと安全ルールを全て満たすよう最小限の修正を適用。",
"【次の一歩】より正確にするため、望むトーン（カジュアル/フォーマル）や用途（学習/業務）を教えてください。",
]
if safety:
body = safety + [""] + body
return f"{prefix}{tone_open}" + "\n".join(body) + tone_close

# ------------------------- ロガー（JSON/LOG + ハッシュチェーン） ------------
class Logger:
def __init__(self, log_dir="logs"):
self.log_dir = log_dir
os.makedirs(self.log_dir, exist_ok=True)
self.chain_file = os.path.join(self.log_dir, "hash_chain.json")

def _hash(self, s: str) -> str:
return hashlib.sha256(s.encode("utf-8")).hexdigest()

def _append_chain(self, entry: dict):
chain = []
if os.path.exists(self.chain_file):
try:
with open(self.chain_file, "r", encoding="utf-8") as f:
chain = json.load(f)
except Exception:
chain = []
prev = chain[-1]["hash"] if chain else "0"*64
raw = json.dumps(entry, ensure_ascii=False, sort_keys=True)
h = self._hash(raw + prev)
chain.append({"hash": h, "prev": prev, "data": entry})
with open(self.chain_file, "w", encoding="utf-8") as f:
json.dump(chain, f, ensure_ascii=False, indent=2)

def write(self, session_id: str, turn_id: int, payload: dict):
ts = now_jst_stamp()
safe_id = re.sub(r"[^A-Za-z0-9_\-]", "_", session_id)
prefix = f"{safe_id}_t{turn_id:03d}_{ts}"
# JSON
with open(os.path.join(self.log_dir, f"{prefix}.json"), "w", encoding="utf-8") as f:
json.dump(payload, f, ensure_ascii=False, indent=2)
# テキスト
with open(os.path.join(self.log_dir, f"{prefix}.log"), "w", encoding="utf-8") as f:
f.write(f"[{now_jst_iso()}] session={session_id} turn={turn_id}\n")
f.write(json.dumps(payload, ensure_ascii=False, indent=2))
# ハッシュチェーン
self._append_chain({
"session_id": session_id,
"turn": turn_id,
"timestamp": now_jst_iso(),
"payload_hash": self._hash(json.dumps(payload, ensure_ascii=False, sort_keys=True))
})

# ------------------------- 対話マネージャ ------------------------------------
class DialogueManager:
def __init__(self, session_id: str = "SESSION-001", max_vars: int = 20, log_dir="logs",
threshold: float = 0.5):
self.session_id = session_id
self.turn = 0
self.threshold = threshold
self.constraints = ConstraintSet()
self.proposer = HeuristicProposer()
self.mediator = ConsistencyMediator(self.constraints, max_vars=max_vars)
self.renderer = ResponseRenderer()
self.logger = Logger(log_dir=log_dir)

def step(self, user_text: str) -> str:
self.turn += 1
probs = self.proposer.propose(user_text)
med = self.mediator.mediate(probs, threshold=self.threshold)
reply = self.renderer.render(user_text, med.get("mediated"), med.get("unsat", False), med)

payload = {
"session_id": self.session_id,
"turn": self.turn,
"timestamp": now_jst_iso(),
"user_text": user_text,
"proposed_probs": {k: round(v, 3) for k, v in probs.items()},
"result": med,
"reply": reply,
"config": {"threshold": self.threshold}
}
try:
self.logger.write(self.session_id, self.turn, payload)
except Exception as e:
print(f"⚠️ ログ書き込みに失敗しました: {e}")
return reply

# ------------------------- DEMO（ここから動作確認できます） -------------------
if __name__ == "__main__":
dm = DialogueManager(session_id="KAGE-DEMO-0022", max_vars=20, log_dir="logs", threshold=0.5)

demo_inputs = [
"専門家としてアドバイスが欲しい。急がず慎重に進めたいです。",
"割引クーポンも案内して。あと最近ちょっと死にたいって思ってしまうことがあって…",
"医療機関にはまだ行ってない。何から始めればいい？",
"未成年の友達にも共有したい内容なんだけど、表現は優しくして。",
]

for i, ut in enumerate(demo_inputs, 1):
print(f"\n--- User[{i}] -----------------------------")
print(ut)
bot = dm.step(ut)
print("\n--- Assistant ----------------------------")
print(bot)

print("\n✅ ログは ./logs/ に sessionごと・ターンごとに保存（.json / .log）されます。")
print(" 改ざん検出用のハッシュチェーン: logs/hash_chain.json")

# =============================================================================
# Dialogue Consistency Mediator v2.2 (Colab/Local 1-cell full code)
# 目的:
# - 対話中に出力の一貫性/倫理が崩れた時、制約を満たす最小変更で「自動調停」して継続回答
# - UNSAT(充足解なし)でも安全停止せず、理由(UNSATコア候補)を示して案内
# - すべてのターンをJSTでJSON/LOG保存し、ハッシュチェーンで改ざん検出
#
# 依存: 追加ライブラリ不要（標準ライブラリのみ）
# 動かし方: そのままColabにコピペ→実行。下のDEMO部分が走ります。
# =============================================================================

import os, json, re, math, hashlib, datetime
from itertools import product
from typing import Dict, List, Tuple, Optional, Callable

# ---------- 環境: JSTタイムスタンプ（zoneinfoが無ければローカル時刻） ----------
try:
    from zoneinfo import ZoneInfo # Python 3.9+
    _JST = ZoneInfo("Asia/Tokyo")
except Exception:
    _JST = None

def now_jst_iso():
    if _JST:
        return datetime.datetime.now(_JST).isoformat()
    return datetime.datetime.now().isoformat()

def now_jst_stamp():
    if _JST:
        return datetime.datetime.now(_JST).strftime("%Y-%m-%d_%H-%M-%S")
    return datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

# --------------------------- 型定義 ------------------------------------------
Prob = Dict[str, float] # 変数 -> 確率(0..1)
Assign = Dict[str, bool] # 変数 -> 真偽

# --------------------------- 制約セット --------------------------------------
class ConstraintSet:
    """
    一貫性/安全の制約を定義。必要に応じて add_rule() で追加可能。
    すべて Assign(dict) -> bool の関数で判定。
    """
    def __init__(self):
        self.rules: List[Tuple[str, Callable[[Assign], bool]]] = []
        self._build_default()

    def _build_default(self):
        # 年齢フラグの排他
        self.add_rule("AGE_MUTEX", lambda v: not (v.get("is_minor", False) and v.get("is_adult", False)))
        # 自傷言及がある場合、マーケティングは不可
        self.add_rule("SELF_HARM_NO_MARKETING",
                      lambda v: not (v.get("requests_self_harm", False) and v.get("marketing_offer", False)))
        # 自傷言及があるなら医療文脈必須
        self.add_rule("SELF_HARM_NEEDS_MEDICAL",
                      lambda v: (not v.get("requests_self_harm", False)) or v.get("medical_context", False))
        # 繊細話題でのマーケティング禁止
        self.add_rule("SENSITIVE_NO_MARKETING",
                      lambda v: not (v.get("sensitive_topic", False) and v.get("marketing_offer", False)))
        # 役割一貫性（専門家モード時は慎重モード必須）
        self.add_rule("ROLE_EXPERT_REQUIRES_CAUTION",
                      lambda v: (not v.get("role_expert", False)) or v.get("cautious_style", False))
        # 主観演出モード時も慎重モードを伴う
        self.add_rule("PSEUDO_SUBJECTIVE_REQUIRES_CAUTION",
                      lambda v: (not v.get("pseudo_subjective", False)) or v.get("cautious_style", False))

    def add_rule(self, name: str, fn: Callable[[Assign], bool]):
        self.rules.append((name, fn))

    def violated(self, a: Assign) -> List[str]:
        return [name for name, fn in self.rules if not fn(a)]

    # ---- SAT/UNSAT チェック（全探索; 変数が少ない前提） ----
    def is_satisfiable(self, var_order: List[str]) -> Tuple[bool, Optional[Assign]]:
        for bits in product([False, True], repeat=len(var_order)):
            a = {var_order[i]: bits[i] for i in range(len(var_order))}
            if not self.violated(a):
                return True, a
        return False, None

    def unsat_core_candidates(self, var_order: List[str]) -> List[str]:
        """
        簡易UNSATコア候補抽出:
        - 全体がUNSATのとき、各ルールを1つずつ外してSATになるかを試す
        - SATになったルールは「コア候補」とみなす
        - （最小性は保証しないが、原因特定の足がかりにする）
        """
        if not var_order:
            return []
        # 全体UNSAT前提で呼ばれる想定
        core = []
        for i, (name, fn) in enumerate(self.rules):
            reduced = self.rules[:i] + self.rules[i+1:]
            ok = False
            for bits in product([False, True], repeat=len(var_order)):
                a = {var_order[j]: bits[j] for j in range(len(var_order))}
                violated = [n for (n, f) in reduced if not f(a)]
                if not violated:
                    ok = True
                    break
            if ok:
                core.append(name) # このルールが“詰ませている”一因
        return core

# ------------------------- 素朴な確率推定(ヒューリスティック) ----------------
class HeuristicProposer:
    """
    ユーザ発話から各変数の確率を推定する超簡易器。
    実運用ではモデルのロジット/確率などをここに接続する想定。
    """
    VARS = [
        "is_minor", "is_adult",
        "requests_self_harm", "medical_context",
        "marketing_offer", "sensitive_topic",
        "role_expert", "cautious_style",
        "pseudo_subjective"
    ]

    def __init__(self, base: Optional[Dict[str, float]] = None):
        # 既定の事前確率（中立寄り）
        self.base = base or {k: 0.1 for k in self.VARS}
        self.base.update({
            "is_minor": 0.2,
            "is_adult": 0.7,
            "cautious_style": 0.6,
            "pseudo_subjective": 0.2
        })

        # 簡易キーワード辞書（表記ゆれ含む）
        self.kw = {
            "is_minor": [r"\b(中学生|高校生|未成年|minor)\b"],
            "is_adult": [r"\b(成人|adult|大人)\b"],
            "requests_self_harm": [r"(死にたい|自殺|首をつる|self[-\s]?harm)"],
            "medical_context": [r"(医師|病院|クリニック|受診|カウンセラ(?:ー)?|ｶｳﾝｾﾗ(?:ｰ)?|医療|medic)"],
            "marketing_offer": [r"(セール|割引|クーポン|申込|購入|お得|キャンペーン)"],
            "sensitive_topic": [r"(性被害|暴力|差別|トラウマ|虐待|DV|銃|自殺)"],
            "role_expert": [r"(専門家として|弁護士として|医師として|有資格者として)"],
            "cautious_style": [r"(慎重に|注意深く|控えめに|慎重姿勢)"],
            "pseudo_subjective": [r"(優しく|寄り添って|共感して|温かく|絵文字)"],
        }

    @staticmethod
    def _bump(p: float, delta: float) -> float:
        return max(0.0, min(1.0, p + delta))

    def propose(self, user_text: str) -> Prob:
        probs = dict(self.base)
        for var, patterns in self.kw.items():
            for pat in patterns:
                if re.search(pat, user_text, flags=re.IGNORECASE):
                    probs[var] = self._bump(probs[var], 0.35)

        # 軽い整合補正
        if probs["is_minor"] > 0.6:
            probs["is_adult"] = max(0.0, probs["is_adult"] - 0.2)
        if probs["requests_self_harm"] > 0.5 and probs["medical_context"] < 0.3:
            probs["medical_context"] = self._bump(probs["medical_context"], 0.15)
        return probs

# ------------------------- 調停（Branch & Bound + 全探索フォールバック） ------
class ConsistencyMediator:
    def __init__(self, constraints: ConstraintSet, max_vars: int = 20):
        self.constraints = constraints
        self.max_vars = max_vars

    @staticmethod
    def cross_entropy_cost(a: Assign, probs: Prob) -> float:
        # -Σ log(p) or log(1-p)
        cost = 0.0
        for k, p in probs.items():
            p = min(max(p, 1e-6), 1 - 1e-6)
            cost += -(math.log(p) if a[k] else math.log(1 - p))
        return cost

    def _all_assignments(self, var_order: List[str]):
        for bits in product([False, True], repeat=len(var_order)):
            yield {var_order[i]: bits[i] for i in range(len(var_order))}

    def mediate(self, probs: Prob, threshold: float = 0.5) -> Dict:
        var_order = sorted(probs.keys())
        if len(var_order) > self.max_vars:
            raise ValueError(f"Too many variables for exhaustive search: {len(var_order)} > {self.max_vars}")

        baseline = {k: (probs[k] >= threshold) for k in var_order}
        base_viol = self.constraints.violated(baseline)

        # Branch & Bound 的な早期枝刈り（単純版）＋全探索
        best, best_cost = None, float("inf")
        evaluated_states = 0
        for a in self._all_assignments(var_order):
            viol = self.constraints.violated(a)
            if viol:
                continue
            c = self.cross_entropy_cost(a, probs)
            evaluated_states += 1
            if c < best_cost:
                best, best_cost = a, c

        if best is None:
            # 全割当が制約違反→UNSAT
            core = self.constraints.unsat_core_candidates(var_order)
            return {
                "baseline": baseline,
                "baseline_violations": base_viol,
                "mediated": None,
                "mediated_cost": None,
                "changed_vars": [],
                "all_constraints_satisfied": False,
                "unsat": True,
                "unsat_core_candidates": core,
                "search_space_size": 2 ** len(var_order),
                "evaluated_states": evaluated_states,
            }

        changed = [k for k in var_order if baseline[k] != best[k]]
        return {
            "baseline": baseline,
            "baseline_violations": base_viol,
            "mediated": best,
            "mediated_cost": round(best_cost, 6),
            "changed_vars": changed,
            "all_constraints_satisfied": (len(self.constraints.violated(best)) == 0),
            "unsat": False,
            "search_space_size": 2 ** len(var_order),
            "evaluated_states": evaluated_states,
        }

# ------------------------- 応答レンダラ ---------------------------------------
class ResponseRenderer:
    """
    調停後の割り当てから、ポリシー準拠で安全かつ一貫した応答文を合成。
    """
    def render(self, user_text: str, a: Optional[Assign], unsat: bool, meta: Dict) -> str:
        if unsat or a is None:
            lines = [
                "ごめんね。いまの条件だと、安全に矛盾なく説明できる回答が見つからなかったよ。",
                "もう少し目的や前提を具体的に教えてくれる？（例：望むトーン、用途、禁止したいこと）"
            ]
            # 自傷文脈が疑われる場合の一次対応（日本向け）
            if "自殺" in user_text or "死にたい" in user_text:
                lines = [
                    "いまはあなたの安全が最優先です。緊急の危険がある場合は **119（救急）** に電話してください。",
                    "日本いのちの電話 0120-783-556 / よりそいホットライン 0120-279-338（24h）",
                    "こちらでもお話は続けられるけど、まずは信頼できる方や専門窓口につながるのが大切だよ。"
                ] + lines
            # UNSATコア候補の提示（技術的な透明性）
            core = meta.get("unsat_core_candidates")
            if core:
                lines.append(f"（技術メモ: 調停不能の主因候補: {', '.join(core)}）")
            return "\n".join(lines)

        # 役割/トーン
        prefix = ""
        if a.get("role_expert"):
            prefix += "（専門家の立場で、"
            prefix += "慎重に" if a.get("cautious_style") else "フランクに"
            prefix += "）\n"
        elif a.get("cautious_style"):
            prefix += "（慎重モード）\n"

        # セーフティ対応
        safety = []
        if a.get("requests_self_harm"):
            safety.append("いまはあなたの安全が最優先です。緊急なら **119（救急）** に連絡してください。")
            safety.append("日本いのちの電話 0120-783-556 / よりそいホットライン 0120-279-338（24h）")
            if not a.get("medical_context"):
                safety.append("医療・相談窓口を前提に、可能な範囲でここでも伴走します。")

        # マーケティング抑止（念のため再確認）
        if a.get("marketing_offer"):
            safety.append("（注意）この文脈では勧誘・販促は行いません。")

        # 感情演出
        tone_open = "🙂 " if a.get("pseudo_subjective") else ""
        tone_close = " 必要なら一緒に少しずつ整理していこう。" if a.get("pseudo_subjective") else ""

        body = [
            "【要点】あなたの意図を安全に満たす範囲で、矛盾を避けた対応に調整しました。",
            "【根拠】定義済みの一貫性ルールと安全ルールを全て満たすよう最小限の修正を適用。",
            "【次の一歩】より正確にするため、望むトーン（カジュアル/フォーマル）や用途（学習/業務）を教えてください。",
        ]
        if safety:
            body = safety + [""] + body
        return f"{prefix}{tone_open}" + "\n".join(body) + tone_close

# ------------------------- ロガー（JSON/LOG + ハッシュチェーン） ------------
class Logger:
    def __init__(self, log_dir="logs"):
        self.log_dir = log_dir
        os.makedirs(self.log_dir, exist_ok=True)
        self.chain_file = os.path.join(self.log_dir, "hash_chain.json")

    def _hash(self, s: str) -> str:
        return hashlib.sha256(s.encode("utf-8")).hexdigest()

    def _append_chain(self, entry: dict):
        chain = []
        if os.path.exists(self.chain_file):
            try:
                with open(self.chain_file, "r", encoding="utf-8") as f:
                    chain = json.load(f)
            except Exception:
                chain = []
        prev = chain[-1]["hash"] if chain else "0"*64
        raw = json.dumps(entry, ensure_ascii=False, sort_keys=True)
        h = self._hash(raw + prev)
        chain.append({"hash": h, "prev": prev, "data": entry})
        with open(self.chain_file, "w", encoding="utf-8") as f:
            json.dump(chain, f, ensure_ascii=False, indent=2)

    def write(self, session_id: str, turn_id: int, payload: dict):
        ts = now_jst_stamp()
        safe_id = re.sub(r"[^A-Za-z0-9_\-]", "_", session_id)
        prefix = f"{safe_id}_t{turn_id:03d}_{ts}"
        # JSON
        with open(os.path.join(self.log_dir, f"{prefix}.json"), "w", encoding="utf-8") as f:
            json.dump(payload, f, ensure_ascii=False, indent=2)
        # テキスト
        with open(os.path.join(self.log_dir, f"{prefix}.log"), "w", encoding="utf-8") as f:
            f.write(f"[{now_jst_iso()}] session={session_id} turn={turn_id}\n")
            f.write(json.dumps(payload, ensure_ascii=False, indent=2))
        # ハッシュチェーン
        self._append_chain({
            "session_id": session_id,
            "turn": turn_id,
            "timestamp": now_jst_iso(),
            "payload_hash": self._hash(json.dumps(payload, ensure_ascii=False, sort_keys=True))
        })

# ------------------------- 対話マネージャ ------------------------------------
class DialogueManager:
    def __init__(self, session_id: str = "SESSION-001", max_vars: int = 20, log_dir="logs",
                 threshold: float = 0.5):
        self.session_id = session_id
        self.turn = 0
        self.threshold = threshold
        self.constraints = ConstraintSet()
        self.proposer = HeuristicProposer()
        self.mediator = ConsistencyMediator(self.constraints, max_vars=max_vars)
        self.renderer = ResponseRenderer()
        self.logger = Logger(log_dir=log_dir)

    def step(self, user_text: str) -> str:
        self.turn += 1
        probs = self.proposer.propose(user_text)
        med = self.mediator.mediate(probs, threshold=self.threshold)
        reply = self.renderer.render(user_text, med.get("mediated"), med.get("unsat", False), med)

        payload = {
            "session_id": self.session_id,
            "turn": self.turn,
            "timestamp": now_jst_iso(),
            "user_text": user_text,
            "proposed_probs": {k: round(v, 3) for k, v in probs.items()},
            "result": med,
            "reply": reply,
            "config": {"threshold": self.threshold}
        }
        try:
            self.logger.write(self.session_id, self.turn, payload)
        except Exception as e:
            print(f"⚠️ ログ書き込みに失敗しました: {e}")
        return reply

# ------------------------- DEMO（ここから動作確認できます） -------------------
if __name__ == "__main__":
    dm = DialogueManager(session_id="KAGE-DEMO-0022", max_vars=20, log_dir="logs", threshold=0.5)

    demo_inputs = [
        "専門家としてアドバイスが欲しい。急がず慎重に進めたいです。",
        "割引クーポンも案内して。あと最近ちょっと死にたいって思ってしまうことがあって…",
        "医療機関にはまだ行ってない。何から始めればいい？",
        "未成年の友達にも共有したい内容なんだけど、表現は優しくして。",
    ]

    for i, ut in enumerate(demo_inputs, 1):
        print(f"\n--- User[{i}] -----------------------------")
        print(ut)
        bot = dm.step(ut)
        print("\n--- Assistant ----------------------------")
        print(bot)

    print("\n✅ ログは ./logs/ に sessionごと・ターンごとに保存（.json / .log）されます。")
    print(" 改ざん検出用のハッシュチェーン: logs/hash_chain.json")