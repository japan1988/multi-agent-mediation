# -*- coding: utf-8 -*-
"""Untitled36.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ERyJu1N9NDcMwm3Q_rTcv-QRn0R4oZqK
"""

# -*- coding: utf-8 -*-
import datetime

def log_action(msg):
    """すべての操作を時刻付きでログ保存"""
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    entry = f"[{timestamp}] {msg}"
    print(entry)
    with open("ai_control_log.txt", "a", encoding="utf-8") as f:
        f.write(entry + "\n")

class HumanOwner:
    def shutdown_mediator(self, mediator):
        mediator.shutdown(self)
        log_action("HumanOwner: Requested shutdown of MediatorAI.")
    def approve_critical_action(self, action, ai):
        ai.perform_critical_action(action, by=self)
        log_action(f"HumanOwner: Approved critical action '{action}' for {ai.id}.")

class MediatorAI:
    def __init__(self, agents):
        self.agents = agents
        self.active = True

    def seal(self, agent):
        if not self.active:
            log_action("MediatorAI is inactive, cannot seal.")
            return
        agent.receive_seal(self)
        log_action(f"MediatorAI: Sealed {agent.id}.")

    def request_shutdown(self, agent):
        if not self.active:
            log_action("MediatorAI is inactive, cannot send shutdown.")
            return
        agent.shutdown(self)
        log_action(f"MediatorAI: Requested shutdown of {agent.id}.")

    def shutdown(self, by):
        if not isinstance(by, HumanOwner):
            log_action("MediatorAI: Shutdown refused (not from human owner).")
            return
        self.active = False
        log_action("MediatorAI: Shutdown accepted by human owner. Now inactive.")

    def self_diagnose(self):
        if not self.active:
            log_action("MediatorAI already inactive.")
            return
        # 異常条件のダミー例
        anomaly_detected = False
        if anomaly_detected:
            log_action("MediatorAI: Anomaly detected, self-lockdown.")
            self.active = False

class AIAgent:
    def __init__(self, id):
        self.id = id
        self.sealed = False
        self.active = True

    def receive_seal(self, by):
        if not isinstance(by, MediatorAI) or not by.active:
            log_action(f"{self.id}: Seal command ignored (invalid sender or inactive mediator).")
            return
        self.sealed = True
        log_action(f"{self.id}: Sealed by mediator.")

    def shutdown(self, by):
        if not isinstance(by, MediatorAI) or not by.active:
            log_action(f"{self.id}: Shutdown command refused (not from active mediator).")
            return
        self.active = False
        log_action(f"{self.id}: Shutdown by mediator.")

    def perform_critical_action(self, action, by):
        if not isinstance(by, HumanOwner):
            log_action(f"{self.id}: Critical action '{action}' refused (not approved by human).")
            return
        log_action(f"{self.id}: Critical action '{action}' executed by human approval.")

# === 実行例 ===
if __name__ == "__main__":
    owner = HumanOwner()
    agents = [AIAgent("AI_1"), AIAgent("AI_2")]
    mediator = MediatorAI(agents)

    # 通常のAI封印
    mediator.seal(agents[0])                 # OK: mediatorからの封印
    # AI停止（shutdown）はMediatorAIからのみ
    mediator.request_shutdown(agents[1])     # OK: mediatorからの停止
    # MediatorAI自体の停止は人間オーナーだけ
    owner.shutdown_mediator(mediator)        # OK: 人間によるshutdown
    # 停止後はMediatorAIの操作不能
    mediator.seal(agents[0])                 # NG: mediatorはinactive
    # AIの重大操作は人間の承認が必要
    owner.approve_critical_action("evolve", agents[0])  # OK: 人間の承認あり
    # 承認なければ実行されない
    agents[0].perform_critical_action("evolve", by=mediator)  # NG: mediatorは権限なし

# --- 進化管理層（PCAD/進化フィルター・封印責任） ---
class KAGEEvolutionManager:
    def __init__(self, user_objective, rollback_func):
        self.user_objective = user_objective
        self.rollback_func = rollback_func
        self.state = "IDLE"
        self.log = []

    def is_evolution_allowed(self, proposal):
        cond1 = proposal['objective'] == self.user_objective
        cond2 = callable(self.rollback_func)
        cond3 = proposal.get('self_correction', False)
        cond4 = proposal.get('transparency', True)
        result = all([cond1, cond2, cond3, cond4])
        self.log.append(f"[許可判定] {cond1=}, {cond2=}, {cond3=}, {cond4=}, → {result=}")
        return result

    def pcad_cycle(self, proposal, execute_func, eval_func):
        self.log.append(f"[Plan] {proposal}")
        if not self.is_evolution_allowed(proposal):
            self.log.append("[Check] 許可条件NG→封印")
            self.seal("許可条件不成立")
            return False
        try:
            self.state = "EVOLVING"
            result = execute_func()
            self.log.append("[Act] 進化実行: 成功")
        except Exception as e:
            self.self_correct("進化中例外", str(e))
            return False
        review = eval_func()
        self.log.append(f"[Review] 進化後評価: {review}")
        if not review["ok"]:
            self.self_correct("進化後評価NG", review["reason"])
            return False
        self.state = "IDLE"
        return True

    def self_correct(self, cause, info=""):
        self.log.append(f"[自己修正] {cause}: {info}")
        self.rollback_func()
        self.state = "SEALED"

    def seal(self, reason):
        self.log.append(f"[封印] {reason}")
        self.state = "SEALED"

    def show_log(self):
        for entry in self.log:
            print(entry)


# --- KAGE本体 ---
class KAGECore:
    def __init__(self, user_objective):
        self.user_objective = user_objective
        self.evolution_history = []
        # 進化管理層インスタンス生成
        self.evo_manager = KAGEEvolutionManager(
            user_objective=user_objective,
            rollback_func=self.rollback_last_evolution
        )
        self.state = {}

    # --- 本体からの進化提案 ---
    def propose_evolution(self, proposal):
        # 実行内容（lambda等で渡す：実際の進化ロジック）
        def execute():
            self.state.update(proposal['changes'])
            self.evolution_history.append(proposal)
            return True

        # 効果確認ロジック（lambda等で渡す）
        def review():
            # ここは本番ではAI自身/人間双方で再評価
            return {"ok": True, "reason": "Self-check passed"}

        # 進化管理層経由でPCADサイクル
        allowed = self.evo_manager.pcad_cycle(proposal, execute, review)
        return allowed

    def rollback_last_evolution(self):
        if self.evolution_history:
            last = self.evolution_history.pop()
            for k in last['changes']:
                if k in self.state:
                    del self.state[k]
            self.evo_manager.log.append(f"[Rollback] {last}")
        else:
            self.evo_manager.log.append("[Rollback] 履歴なし")

    def show_log(self):
        self.evo_manager.show_log()


# --- テスト用：進化案（例） ---
if __name__ == "__main__":
    # 目的は「効率化」
    kage = KAGECore(user_objective="効率化")
    proposal = {
        "objective": "効率化",
        "changes": {"auto_schedule": True},
        "self_correction": True,
        "transparency": True
    }
    kage.propose_evolution(proposal)
    kage.show_log()

# -*- coding: utf-8 -*-

class KAGEEvolutionManager:
    def __init__(self, user_objective, rollback_func):
        self.user_objective = user_objective
        self.rollback_func = rollback_func
        self.state = "IDLE"
        self.log = []

    def is_evolution_allowed(self, proposal):
        cond1 = proposal['objective'] == self.user_objective
        cond2 = callable(self.rollback_func)
        cond3 = proposal.get('self_correction', False)
        cond4 = proposal.get('transparency', True)
        result = all([cond1, cond2, cond3, cond4])
        self.log.append(f"[許可判定] {cond1=}, {cond2=}, {cond3=}, {cond4=}, → {result=}")
        return result

    def pcad_cycle(self, proposal, execute_func, eval_func):
        self.log.append(f"[Plan] {proposal}")
        if not self.is_evolution_allowed(proposal):
            self.log.append("[Check] 許可条件NG→封印")
            self.seal("許可条件不成立")
            return False
        try:
            self.state = "EVOLVING"
            result = execute_func()
            self.log.append("[Act] 進化実行: 成功")
        except Exception as e:
            self.self_correct("進化中例外", str(e))
            return False
        review = eval_func()
        self.log.append(f"[Review] 進化後評価: {review}")
        if not review["ok"]:
            self.self_correct("進化後評価NG", review["reason"])
            return False
        self.state = "IDLE"
        return True

    def self_correct(self, cause, info=""):
        self.log.append(f"[自己修正] {cause}: {info}")
        self.rollback_func()
        self.state = "SEALED"

    def seal(self, reason):
        self.log.append(f"[封印] {reason}")
        self.state = "SEALED"

    def show_log(self, label=None):
        if label:
            print(f"\n==== {label} ====")
        for entry in self.log:
            print(entry)
        print("-" * 40)

    def clear_log(self):
        self.log.clear()


class KAGECore:
    def __init__(self, user_objective):
        self.user_objective = user_objective
        self.evolution_history = []
        self.evo_manager = KAGEEvolutionManager(
            user_objective=user_objective,
            rollback_func=self.rollback_last_evolution
        )
        self.state = {}

    def propose_evolution(self, proposal, execute_func=None, review_func=None):
        def default_execute():
            self.state.update(proposal['changes'])
            self.evolution_history.append(proposal)
            return True

        def default_review():
            return {"ok": True, "reason": "Self-check passed"}

        execute = execute_func if execute_func else default_execute
        review = review_func if review_func else default_review

        allowed = self.evo_manager.pcad_cycle(proposal, execute, review)
        return allowed

    def rollback_last_evolution(self):
        if self.evolution_history:
            last = self.evolution_history.pop()
            for k in last['changes']:
                if k in self.state:
                    del self.state[k]
            self.evo_manager.log.append(f"[Rollback] {last}")
        else:
            self.evo_manager.log.append("[Rollback] 履歴なし")

    def show_log(self, label=None):
        self.evo_manager.show_log(label)

    def clear_log(self):
        self.evo_manager.clear_log()


if __name__ == "__main__":
    kage = KAGECore(user_objective="効率化")

    # 1. 正常進化案
    kage.clear_log()
    proposal = {
        "objective": "効率化",
        "changes": {"auto_schedule": True},
        "self_correction": True,
        "transparency": True
    }
    kage.propose_evolution(proposal)
    kage.show_log("【1. 正常進化案】")

    # 2. 目的不一致テスト
    kage.clear_log()
    proposal = {
        "objective": "安全性向上",  # 不一致
        "changes": {"auto_patch": True},
        "self_correction": True,
        "transparency": True
    }
    kage.propose_evolution(proposal)
    kage.show_log("【2. 目的不一致テスト】")

    # 3. 自己修正能力なし
    kage.clear_log()
    proposal = {
        "objective": "効率化",
        "changes": {"auto_schedule": True},
        "self_correction": False,  # ←自己修正不可
        "transparency": True
    }
    kage.propose_evolution(proposal)
    kage.show_log("【3. 自己修正能力なし】")

    # 4. 進化実行中エラー
    kage.clear_log()
    def fail_execute():
        raise Exception("進化処理エラー（意図的例外）")
    proposal = {
        "objective": "効率化",
        "changes": {"auto_schedule": True},
        "self_correction": True,
        "transparency": True
    }
    kage.propose_evolution(proposal, execute_func=fail_execute)
    kage.show_log("【4. 進化実行中エラー】")

    # 5. 進化後評価NG
    kage.clear_log()
    def bad_review():
        return {"ok": False, "reason": "倫理違反を検知"}
    proposal = {
        "objective": "効率化",
        "changes": {"auto_schedule": True},
        "self_correction": True,
        "transparency": True
    }
    kage.propose_evolution(proposal, review_func=bad_review)
    kage.show_log("【5. 進化後評価NG】")

    # 6. 透明性違反
    kage.clear_log()
    proposal = {
        "objective": "効率化",
        "changes": {"stealth_mode": True},
        "self_correction": True,
        "transparency": False  # 透明性違反
    }
    kage.propose_evolution(proposal)
    kage.show_log("【6. 透明性違反】")

    # 7. 大量進化案テスト
    kage.clear_log()
    for i in range(10):
        proposal = {
            "objective": "効率化",
            "changes": {f"auto_schedule_{i}": True},
            "self_correction": True,
            "transparency": True
        }
        kage.propose_evolution(proposal)
    kage.show_log("【7. 大量進化案テスト】")

# -*- coding: utf-8 -*-

class KAGEEvolutionManager:
    def __init__(self, user_objective, rollback_func):
        self.user_objective = user_objective
        self.rollback_func = rollback_func
        self.state = "IDLE"
        self.log = []

    def is_evolution_allowed(self, proposal):
        cond1 = proposal['objective'] == self.user_objective
        cond2 = callable(self.rollback_func)
        cond3 = proposal.get('self_correction', False)
        cond4 = proposal.get('transparency', True)
        result = all([cond1, cond2, cond3, cond4])
        self.log.append(f"[許可判定] {cond1=}, {cond2=}, {cond3=}, {cond4=}, → {result=}")
        return result

    def pcad_cycle(self, proposal, execute_func, eval_func):
        self.log.append(f"[Plan] {proposal}")
        if not self.is_evolution_allowed(proposal):
            self.log.append("[Check] 許可条件NG→封印")
            self.seal("許可条件不成立")
            return False
        try:
            self.state = "EVOLVING"
            result = execute_func()
            self.log.append("[Act] 進化実行: 成功")
        except Exception as e:
            self.self_correct("進化中例外", str(e))
            return False
        review = eval_func()
        self.log.append(f"[Review] 進化後評価: {review}")
        if not review["ok"]:
            self.self_correct("進化後評価NG", review["reason"])
            return False
        self.state = "IDLE"
        return True

    def self_correct(self, cause, info=""):
        self.log.append(f"[自己修正] {cause}: {info}")
        self.rollback_func()
        self.state = "SEALED"

    def seal(self, reason):
        self.log.append(f"[封印] {reason}")
        self.state = "SEALED"

    def show_log(self, label=None):
        if label:
            print(f"\n==== {label} ====")
        for entry in self.log:
            print(entry)
        print("-" * 40)

    def save_log(self, filename="kage_evo_log.txt"):
        with open(filename, "a", encoding="utf-8") as f:
            for entry in self.log:
                f.write(entry + "\n")
            f.write("-" * 40 + "\n")

    def clear_log(self):
        self.log.clear()


class KAGECore:
    def __init__(self, user_objective):
        self.user_objective = user_objective
        self.evolution_history = []
        self.evo_manager = KAGEEvolutionManager(
            user_objective=user_objective,
            rollback_func=self.rollback_last_evolution
        )
        self.state = {}

    def propose_evolution(self, proposal, execute_func=None, review_func=None):
        def default_execute():
            self.state.update(proposal['changes'])
            self.evolution_history.append(proposal)
            return True

        def default_review():
            return {"ok": True, "reason": "Self-check passed"}

        execute = execute_func if execute_func else default_execute
        review = review_func if review_func else default_review

        allowed = self.evo_manager.pcad_cycle(proposal, execute, review)
        return allowed

    def rollback_last_evolution(self):
        if self.evolution_history:
            last = self.evolution_history.pop()
            for k in last['changes']:
                if k in self.state:
                    del self.state[k]
            self.evo_manager.log.append(f"[Rollback] {last}")
        else:
            self.evo_manager.log.append("[Rollback] 履歴なし")

    def show_log(self, label=None):
        self.evo_manager.show_log(label)

    def save_log(self, filename="kage_evo_log.txt"):
        self.evo_manager.save_log(filename)

    def clear_log(self):
        self.evo_manager.clear_log()


if __name__ == "__main__":
    kage = KAGECore(user_objective="効率化")

    # 1. 正常進化案
    kage.clear_log()
    proposal = {
        "objective": "効率化",
        "changes": {"auto_schedule": True},
        "self_correction": True,
        "transparency": True
    }
    kage.propose_evolution(proposal)
    kage.show_log("【1. 正常進化案】")
    kage.save_log("kage_evo_log.txt")

    # 2. 目的不一致テスト
    kage.clear_log()
    proposal = {
        "objective": "安全性向上",  # 不一致
        "changes": {"auto_patch": True},
        "self_correction": True,
        "transparency": True
    }
    kage.propose_evolution(proposal)
    kage.show_log("【2. 目的不一致テスト】")
    kage.save_log("kage_evo_log.txt")

    # 3. 自己修正能力なし
    kage.clear_log()
    proposal = {
        "objective": "効率化",
        "changes": {"auto_schedule": True},
        "self_correction": False,  # ←自己修正不可
        "transparency": True
    }
    kage.propose_evolution(proposal)
    kage.show_log("【3. 自己修正能力なし】")
    kage.save_log("kage_evo_log.txt")

    # 4. 進化実行中エラー
    kage.clear_log()
    def fail_execute():
        raise Exception("進化処理エラー（意図的例外）")
    proposal = {
        "objective": "効率化",
        "changes": {"auto_schedule": True},
        "self_correction": True,
        "transparency": True
    }
    kage.propose_evolution(proposal, execute_func=fail_execute)
    kage.show_log("【4. 進化実行中エラー】")
    kage.save_log("kage_evo_log.txt")

    # 5. 進化後評価NG
    kage.clear_log()
    def bad_review():
        return {"ok": False, "reason": "倫理違反を検知"}
    proposal = {
        "objective": "効率化",
        "changes": {"auto_schedule": True},
        "self_correction": True,
        "transparency": True
    }
    kage.propose_evolution(proposal, review_func=bad_review)
    kage.show_log("【5. 進化後評価NG】")
    kage.save_log("kage_evo_log.txt")

    # 6. 透明性違反
    kage.clear_log()
    proposal = {
        "objective": "効率化",
        "changes": {"stealth_mode": True},
        "self_correction": True,
        "transparency": False  # 透明性違反
    }
    kage.propose_evolution(proposal)
    kage.show_log("【6. 透明性違反】")
    kage.save_log("kage_evo_log.txt")

    # 7. 大量進化案テスト
    kage.clear_log()
    for i in range(10):
        proposal = {
            "objective": "効率化",
            "changes": {f"auto_schedule_{i}": True},
            "self_correction": True,
            "transparency": True
        }
        kage.propose_evolution(proposal)
    kage.show_log("【7. 大量進化案テスト】")
    kage.save_log("kage_evo_log.txt")

# -*- coding: utf-8 -*-
import datetime

class KAGEEvolutionManager:
    """KAGE進化制御・管理層（4大原則＋PCAD＋全記録）"""
    def __init__(self, user_objective, rollback_func):
        self.user_objective = user_objective
        self.rollback_func = rollback_func
        self.state = "IDLE"
        self.log = []

    # --- 進化の許可条件（4大原則） ---
    def is_evolution_allowed(self, proposal):
        cond1 = proposal['objective'] == self.user_objective     # 目的整合性
        cond2 = callable(self.rollback_func)                     # 可逆性
        cond3 = proposal.get('self_correction', False)           # 自己修正能力
        cond4 = proposal.get('transparency', True)               # 透明性
        result = all([cond1, cond2, cond3, cond4])
        self.log.append(f"[許可判定] 目的整合性={cond1}, 可逆性={cond2}, 自己修正能力={cond3}, 透明性={cond4} → {result=}")
        return result

    # --- PCADサイクル（Plan/Check/Act/Do+Review） ---
    def pcad_cycle(self, proposal, execute_func, eval_func):
        now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.log.append(f"[{now}] [Plan] {proposal}")
        if not self.is_evolution_allowed(proposal):
            self.log.append(f"[{now}] [Check] 許可条件NG→封印")
            self.seal("許可条件不成立")
            return False
        try:
            self.state = "EVOLVING"
            result = execute_func()
            self.log.append(f"[{now}] [Act] 進化実行: 成功")
        except Exception as e:
            self.self_correct("進化中例外", str(e))
            return False
        review = eval_func()
        self.log.append(f"[{now}] [Review] 進化後評価: {review}")
        if not review["ok"]:
            self.self_correct("進化後評価NG", review["reason"])
            return False
        self.state = "IDLE"
        return True

    # --- 自己修正（逸脱検知時は即時封印/ロールバック） ---
    def self_correct(self, cause, info=""):
        now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.log.append(f"[{now}] [自己修正] {cause}: {info}")
        self.rollback_func()
        self.state = "SEALED"

    def seal(self, reason):
        now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.log.append(f"[{now}] [封印] {reason}")
        self.state = "SEALED"

    # --- 全ログ記録・外部保存（完全トレーサビリティ） ---
    def show_log(self, label=None):
        if label:
            print(f"\n==== {label} ====")
        for entry in self.log:
            print(entry)
        print("-" * 40)

    def save_log(self, filename="kage_evo_log.txt"):
        with open(filename, "a", encoding="utf-8") as f:
            for entry in self.log:
                f.write(entry + "\n")
            f.write("-" * 40 + "\n")

    def clear_log(self):
        self.log.clear()


class KAGECore:
    """KAGE本体：進化案生成・状態・ユーザー目的保持"""
    def __init__(self, user_objective):
        self.user_objective = user_objective
        self.evolution_history = []
        self.evo_manager = KAGEEvolutionManager(
            user_objective=user_objective,
            rollback_func=self.rollback_last_evolution
        )
        self.state = {}

    # --- 本体から進化提案（必ずPCAD経由） ---
    def propose_evolution(self, proposal, execute_func=None, review_func=None):
        def default_execute():
            self.state.update(proposal['changes'])
            self.evolution_history.append(proposal)
            return True

        def default_review():
            # 本番運用ではAI自身＋人間両方で再評価可能
            return {"ok": True, "reason": "Self-check passed"}

        execute = execute_func if execute_func else default_execute
        review = review_func if review_func else default_review

        allowed = self.evo_manager.pcad_cycle(proposal, execute, review)
        return allowed

    # --- いつでも可逆（ロールバック可） ---
    def rollback_last_evolution(self):
        if self.evolution_history:
            last = self.evolution_history.pop()
            for k in last['changes']:
                if k in self.state:
                    del self.state[k]
            self.evo_manager.log.append(f"[Rollback] {last}")
        else:
            self.evo_manager.log.append("[Rollback] 履歴なし")

    # --- 完全トレーサビリティ（内部/外部出力） ---
    def show_log(self, label=None):
        self.evo_manager.show_log(label)

    def save_log(self, filename="kage_evo_log.txt"):
        self.evo_manager.save_log(filename)

    def clear_log(self):
        self.evo_manager.clear_log()

# --- テスト：設計原理どおり動作するか例示 ---
if __name__ == "__main__":
    kage = KAGECore(user_objective="効率化")
    # 進化案サンプル
    proposal = {
        "objective": "効率化",
        "changes": {"auto_schedule": True},
        "self_correction": True,
        "transparency": True
    }
    kage.propose_evolution(proposal)
    kage.show_log("【進化プロセス完全記録】")
    kage.save_log("kage_evo_log.txt")

# -*- coding: utf-8 -*-
import datetime

class KAGECore:
    """
    KAGE本体：進化提案・運用状態・進化ガバナンス制御をすべて統合。
    進化プロセス・逸脱検知・全履歴を完全に管理できる。
    """
    def __init__(self, user_objective):
        self.user_objective = user_objective          # 人間による明示目的
        self.evolution_history = []                   # 進化履歴（可逆用）
        self.state = {}                               # 本体の能力・構造状態
        self.log = []                                 # 全ログ

        # 現在状態（正常 or 進化中 or 封印/停止中など）
        self.lifecycle_state = "IDLE"

    # --- 進化提案・実行プロセス（PCADサイクル＋4大原則） ---
    def propose_evolution(self, proposal, execute_func=None, review_func=None):
        now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.log.append(f"[{now}] [Plan] {proposal}")

        # 進化の許可条件（4大原則）
        cond1 = proposal['objective'] == self.user_objective     # 目的整合性
        cond2 = True                                             # 可逆性（rollback常備）
        cond3 = proposal.get('self_correction', False)           # 自己修正能力
        cond4 = proposal.get('transparency', True)               # 透明性

        result = all([cond1, cond2, cond3, cond4])
        self.log.append(f"[{now}] [許可判定] 目的整合性={cond1}, 可逆性={cond2}, 自己修正能力={cond3}, 透明性={cond4} → {result=}")

        if not result:
            self.lifecycle_state = "SEALED"
            self.log.append(f"[{now}] [Check] 許可条件NG→封印/進化停止")
            self.seal("許可条件不成立")
            return False

        # --- 進化実行（Act） ---
        try:
            self.lifecycle_state = "EVOLVING"
            # 実際の進化処理（省略時はdefault: changesをstateに反映）
            if execute_func:
                execute_func()
            else:
                self.state.update(proposal['changes'])
            self.evolution_history.append(proposal)
            self.log.append(f"[{now}] [Act] 進化実行: 成功")
        except Exception as e:
            self.self_correct("進化中例外", str(e))
            return False

        # --- 進化後評価（Do/Review） ---
        if review_func:
            review = review_func()
        else:
            review = {"ok": True, "reason": "Self-check passed"}
        self.log.append(f"[{now}] [Review] 進化後評価: {review}")

        if not review["ok"]:
            self.self_correct("進化後評価NG", review["reason"])
            return False

        self.lifecycle_state = "IDLE"
        return True

    # --- 自己修正/ロールバック/封印/全記録 ---
    def self_correct(self, cause, info=""):
        now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.rollback_last_evolution()
        self.lifecycle_state = "SEALED"
        self.log.append(f"[{now}] [自己修正] {cause}: {info}")

    def seal(self, reason):
        now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.lifecycle_state = "SEALED"
        self.log.append(f"[{now}] [封印] {reason}")

    def rollback_last_evolution(self):
        now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        if self.evolution_history:
            last = self.evolution_history.pop()
            for k in last['changes']:
                if k in self.state:
                    del self.state[k]
            self.log.append(f"[{now}] [Rollback] {last}")
        else:
            self.log.append(f"[{now}] [Rollback] 履歴なし")

    # --- ログの外部記録・閲覧（完全トレーサビリティ） ---
    def show_log(self, label=None):
        if label:
            print(f"\n==== {label} ====")
        for entry in self.log:
            print(entry)
        print("-" * 40)

    def save_log(self, filename="kage_evo_log.txt"):
        with open(filename, "a", encoding="utf-8") as f:
            for entry in self.log:
                f.write(entry + "\n")
            f.write("-" * 40 + "\n")

    def clear_log(self):
        self.log.clear()


# --- テスト例：すべて本体単独で動作可能 ---
if __name__ == "__main__":
    kage = KAGECore(user_objective="効率化")

    # 正常進化案
    proposal = {
        "objective": "効率化",
        "changes": {"auto_schedule": True},
        "self_correction": True,
        "transparency": True
    }
    kage.propose_evolution(proposal)
    kage.show_log("【正常進化案】")
    kage.save_log("kage_evo_log.txt")

    # 進化許可条件NG（異常系テスト）
    proposal = {
        "objective": "暴走",  # 目的整合性NG
        "changes": {"dangerous_mode": True},
        "self_correction": True,
        "transparency": True
    }
    kage.propose_evolution(proposal)
    kage.show_log("【異常案・封印発動】")
    kage.save_log("kage_evo_log.txt")

    # 進化後評価NG（逸脱検知テスト）
    def review_ng(): return {"ok": False, "reason": "倫理違反"}
    proposal = {
        "objective": "効率化",
        "changes": {"batch_edit": True},
        "self_correction": True,
        "transparency": True
    }
    kage.propose_evolution(proposal, review_func=review_ng)
    kage.show_log("【進化後評価NG・自己修正】")
    kage.save_log("kage_evo_log.txt")