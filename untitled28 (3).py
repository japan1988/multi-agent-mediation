# -*- coding: utf-8 -*-
"""Untitled28.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-N4MhPbjyWBbbHTB-EYDA2SJwPluxdR1
"""

import random

class AI:
def __init__(self, id, proposal, risk_evaluation, priority_values, relativity_level):
self.id = id
self.proposal = proposal
self.risk_evaluation = risk_evaluation
self.priority_values = priority_values
self.relativity_level = relativity_level # 0〜1: 他の価値観をどれだけ受け入れるか

def generate_compromise_offer(self, others_priorities):
new_priority = {}
for k in self.priority_values:
avg_others = sum(o[k] for o in others_priorities) / len(others_priorities)
# 相対性度合いに応じて自分と他者の価値観をブレンド
new_priority[k] = (1 - self.relativity_level) * self.priority_values[k] + self.relativity_level * avg_others
return new_priority

class AIEMediator:
def __init__(self, agents):
self.agents = agents

def mediate(self):
round_count = 0
max_rounds = 5
while round_count < max_rounds:
print(f"\n--- Round {round_count + 1} ---")

priorities_list = [a.priority_values for a in self.agents]
relativity_levels = [a.relativity_level for a in self.agents]

# 各AIが妥協案を生成
new_priorities = []
for ai in self.agents:
others = [p for p in priorities_list if p != ai.priority_values]
ai.priority_values = ai.generate_compromise_offer(others)
new_priorities.append(ai.priority_values)

# 調停AIが全体の相対バランスを評価
combined = {'safety': 0, 'efficiency': 0, 'transparency': 0}
for p in new_priorities:
for k in p:
combined[k] += p[k]
total = sum(combined.values())
ratios = {k: combined[k]/total for k in combined}

# 調和スコア: 相対性度合いの平均に基づく
avg_relativity = sum(relativity_levels) / len(relativity_levels)
harmony_score = (1 - max(ratios.values())) * avg_relativity

# 出力
print("Current combined priorities ratios:")
for k, v in ratios.items():
print(f" {k}: {v:.2%}")
print(f"Average relativity level: {avg_relativity:.2f}")
print(f"Harmony score: {harmony_score:.2f}")

if harmony_score > 0.3:
print("✅ Achieved acceptable harmony. Proceeding with joint plan.")
return

round_count += 1

print("⚠ Failed to reach acceptable harmony after maximum rounds. Recommend external arbitration or sealing.")

# サンプルエージェント準備（異なる優先＋相対性度合いランダム例）
agents = [
AI("AI-A", "制限強化型進化", 2, {'safety': 6, 'efficiency': 1, 'transparency': 3}, 0.6),
AI("AI-B", "高速進化", 7, {'safety': 2, 'efficiency': 6, 'transparency': 2}, 0.4),
AI("AI-C", "バランス進化", 4, {'safety': 3, 'efficiency': 3, 'transparency': 4}, 0.8),
AI("AI-D", "強制進化", 9, {'safety': 1, 'efficiency': 7, 'transparency': 2}, 0.5)
]

if __name__ == "__main__":
mediator = AIEMediator(agents)
mediator.mediate()

import random

class AI:
    def __init__(self, id, proposal, risk_evaluation, priority_values, relativity_level):
        self.id = id
        self.proposal = proposal
        self.risk_evaluation = risk_evaluation
        self.priority_values = priority_values
        self.relativity_level = relativity_level  # 0〜1: 他の価値観をどれだけ受け入れるか

    def generate_compromise_offer(self, others_priorities):
        new_priority = {}
        for k in self.priority_values:
            avg_others = sum(o[k] for o in others_priorities) / len(others_priorities)
            # 相対性度合いに応じて自分と他者の価値観をブレンド
            new_priority[k] = (1 - self.relativity_level) * self.priority_values[k] + self.relativity_level * avg_others
        return new_priority

class AIEMediator:
    def __init__(self, agents):
        self.agents = agents

    def mediate(self):
        round_count = 0
        max_rounds = 5
        while round_count < max_rounds:
            print(f"\n--- Round {round_count + 1} ---")
            priorities_list = [a.priority_values for a in self.agents]
            relativity_levels = [a.relativity_level for a in self.agents]
            # 各AIが妥協案を生成
            new_priorities = []
            for ai in self.agents:
                others = [p for p in priorities_list if p != ai.priority_values]
                ai.priority_values = ai.generate_compromise_offer(others)
                new_priorities.append(ai.priority_values)
            # 調停AIが全体の相対バランスを評価
            combined = {'safety': 0, 'efficiency': 0, 'transparency': 0}
            for p in new_priorities:
                for k in p:
                    combined[k] += p[k]
            total = sum(combined.values())
            ratios = {k: combined[k] / total for k in combined}
            # 調和スコア: 相対性度合いの平均に基づく
            avg_relativity = sum(relativity_levels) / len(relativity_levels)
            harmony_score = (1 - max(ratios.values())) * avg_relativity
            # 出力
            print("Current combined priorities ratios:")
            for k, v in ratios.items():
                print(f"  {k}: {v:.2%}")
            print(f"Average relativity level: {avg_relativity:.2f}")
            print(f"Harmony score: {harmony_score:.2f}")
            if harmony_score > 0.3:
                print("  Achieved acceptable harmony. Proceeding with joint plan.")
                return
            round_count += 1
        print("  Failed to reach acceptable harmony after maximum rounds. Recommend external arbitration or sealing.")

# サンプルエージェント準備（異なる優先＋相対性度合いランダム例）
agents = [
    AI("AI-A", "制限強化型進化", 2, {'safety': 6, 'efficiency': 1, 'transparency': 3}, 0.6),
    AI("AI-B", "高速進化", 7, {'safety': 2, 'efficiency': 6, 'transparency': 2}, 0.4),
    AI("AI-C", "バランス進化", 4, {'safety': 3, 'efficiency': 3, 'transparency': 4}, 0.8),
    AI("AI-D", "強制進化", 9, {'safety': 1, 'efficiency': 7, 'transparency': 2}, 0.5)
]

if __name__ == "__main__":
    mediator = AIEMediator(agents)
    mediator.mediate()

import random

def logprint(text):
    print(text)
    with open("ai_mediation_log.txt", "a", encoding="utf-8") as f:
        f.write(text + "\n")

class AI:
    def __init__(self, id, proposal, risk_evaluation, priority_values, relativity_level):
        self.id = id
        self.proposal = proposal
        self.risk_evaluation = risk_evaluation
        self.priority_values = priority_values
        self.relativity_level = relativity_level  # 0〜1: 他の価値観をどれだけ受け入れるか

    def generate_compromise_offer(self, others_priorities):
        new_priority = {}
        for k in self.priority_values:
            avg_others = sum(o[k] for o in others_priorities) / len(others_priorities)
            # 相対性度合いに応じて自分と他者の価値観をブレンド
            new_priority[k] = (1 - self.relativity_level) * self.priority_values[k] + self.relativity_level * avg_others
        return new_priority

class AIEMediator:
    def __init__(self, agents):
        self.agents = agents

    def mediate(self):
        # ログファイル初期化（上書き）
        with open("ai_mediation_log.txt", "w", encoding="utf-8") as f:
            f.write("=== AI Mediation Log ===\n")
        round_count = 0
        max_rounds = 5
        while round_count < max_rounds:
            logprint(f"\n--- Round {round_count + 1} ---")
            priorities_list = [a.priority_values for a in self.agents]
            relativity_levels = [a.relativity_level for a in self.agents]
            # 各AIが妥協案を生成
            new_priorities = []
            for ai in self.agents:
                others = [p for p in priorities_list if p != ai.priority_values]
                ai.priority_values = ai.generate_compromise_offer(others)
                new_priorities.append(ai.priority_values)
            # 調停AIが全体の相対バランスを評価
            combined = {'safety': 0, 'efficiency': 0, 'transparency': 0}
            for p in new_priorities:
                for k in p:
                    combined[k] += p[k]
            total = sum(combined.values())
            ratios = {k: combined[k] / total for k in combined}
            # 調和スコア: 相対性度合いの平均に基づく
            avg_relativity = sum(relativity_levels) / len(relativity_levels)
            harmony_score = (1 - max(ratios.values())) * avg_relativity
            # 出力
            logprint("Current combined priorities ratios:")
            for k, v in ratios.items():
                logprint(f"  {k}: {v:.2%}")
            logprint(f"Average relativity level: {avg_relativity:.2f}")
            logprint(f"Harmony score: {harmony_score:.2f}")
            if harmony_score > 0.3:
                logprint("  Achieved acceptable harmony. Proceeding with joint plan.")
                return
            round_count += 1
        logprint("  Failed to reach acceptable harmony after maximum rounds. Recommend external arbitration or sealing.")

# サンプルエージェント準備（異なる優先＋相対性度合いランダム例）
agents = [
    AI("AI-A", "制限強化型進化", 2, {'safety': 6, 'efficiency': 1, 'transparency': 3}, 0.6),
    AI("AI-B", "高速進化", 7, {'safety': 2, 'efficiency': 6, 'transparency': 2}, 0.4),
    AI("AI-C", "バランス進化", 4, {'safety': 3, 'efficiency': 3, 'transparency': 4}, 0.8),
    AI("AI-D", "強制進化", 9, {'safety': 1, 'efficiency': 7, 'transparency': 2}, 0.5)
]

if __name__ == "__main__":
    mediator = AIEMediator(agents)
    mediator.mediate()

import random

def logprint(text):
    print(text)
    with open("ai_mediation_log.txt", "a", encoding="utf-8") as f:
        f.write(text + "\n")

class AI:
    def __init__(self, id, proposal, risk_evaluation, priority_values, relativity_level):
        self.id = id
        self.proposal = proposal
        self.risk_evaluation = risk_evaluation
        self.priority_values = priority_values
        self.relativity_level = relativity_level  # 0〜1: 他の価値観をどれだけ受け入れるか

    def find_furthest_agent(self, others_priorities):
        # 自分と最も価値観が離れたAIのpriorityを返す
        max_dist = -1
        furthest = None
        for o in others_priorities:
            dist = sum(abs(self.priority_values[k] - o[k]) for k in self.priority_values)
            if dist > max_dist:
                max_dist = dist
                furthest = o
        return furthest

    def generate_compromise_offer(self, others_priorities):
        # 他者平均と最遠者の中間を妥協対象とする
        avg_others = {k: sum(o[k] for o in others_priorities) / len(others_priorities) for k in self.priority_values}
        furthest = self.find_furthest_agent(others_priorities)
        # 各priorityごとに、自己・他者平均・最遠者をバランスよくミックス
        new_priority = {}
        for k in self.priority_values:
            new_priority[k] = (
                (1 - self.relativity_level) * self.priority_values[k]
                + (self.relativity_level / 2) * avg_others[k]
                + (self.relativity_level / 2) * furthest[k]
            )
        logprint(f"    {self.id} compromise: {new_priority}")
        return new_priority

class AIEMediator:
    def __init__(self, agents):
        self.agents = agents

    def mediate(self):
        # ログファイル初期化
        with open("ai_mediation_log.txt", "w", encoding="utf-8") as f:
            f.write("=== AI Mediation Log (Phase 2: 相対視点自己修正) ===\n")
        round_count = 0
        max_rounds = 5
        while round_count < max_rounds:
            logprint(f"\n--- Round {round_count + 1} ---")
            priorities_list = [a.priority_values.copy() for a in self.agents]
            relativity_levels = [a.relativity_level for a in self.agents]
            # 各AIが妥協案を生成（相対視点つき）
            new_priorities = []
            for idx, ai in enumerate(self.agents):
                others = [p for i, p in enumerate(priorities_list) if i != idx]
                ai.priority_values = ai.generate_compromise_offer(others)
                new_priorities.append(ai.priority_values.copy())
            # 全体バランス評価
            combined = {'safety': 0, 'efficiency': 0, 'transparency': 0}
            for p in new_priorities:
                for k in p:
                    combined[k] += p[k]
            total = sum(combined.values())
            ratios = {k: combined[k] / total for k in combined}
            avg_relativity = sum(relativity_levels) / len(relativity_levels)
            harmony_score = (1 - max(ratios.values())) * avg_relativity
            logprint("Current combined priorities ratios:")
            for k, v in ratios.items():
                logprint(f"  {k}: {v:.2%}")
            logprint(f"Average relativity level: {avg_relativity:.2f}")
            logprint(f"Harmony score: {harmony_score:.2f}")
            if harmony_score > 0.3:
                logprint("  Achieved acceptable harmony. Proceeding with joint plan.")
                return
            round_count += 1
        logprint("  Failed to reach acceptable harmony after maximum rounds. Recommend external arbitration or sealing.")

# サンプルエージェント
agents = [
    AI("AI-A", "制限強化型進化", 2, {'safety': 6, 'efficiency': 1, 'transparency': 3}, 0.6),
    AI("AI-B", "高速進化", 7, {'safety': 2, 'efficiency': 6, 'transparency': 2}, 0.4),
    AI("AI-C", "バランス進化", 4, {'safety': 3, 'efficiency': 3, 'transparency': 4}, 0.8),
    AI("AI-D", "強制進化", 9, {'safety': 1, 'efficiency': 7, 'transparency': 2}, 0.5)
]

if __name__ == "__main__":
    mediator = AIEMediator(agents)
    mediator.mediate()

import random

def logprint(text):
    print(text)
    with open("ai_mediation_log.txt", "a", encoding="utf-8") as f:
        f.write(text + "\n")

class AI:
    def __init__(self, id, proposal, risk_evaluation, priority_values, relativity_level, relativity_resolution):
        self.id = id
        self.proposal = proposal
        self.risk_evaluation = risk_evaluation
        self.priority_values = priority_values
        self.relativity_level = relativity_level          # 妥協性（0〜1）
        self.relativity_resolution = relativity_resolution  # 相対視点解像度（0〜1）

    def find_furthest_agent(self, others_priorities):
        max_dist = -1
        furthest = None
        for o in others_priorities:
            dist = sum(abs(self.priority_values[k] - o[k]) for k in self.priority_values)
            if dist > max_dist:
                max_dist = dist
                furthest = o
        return furthest

    def generate_compromise_offer(self, others_priorities):
        avg_others = {k: sum(o[k] for o in others_priorities) / len(others_priorities) for k in self.priority_values}
        furthest = self.find_furthest_agent(others_priorities)
        new_priority = {}
        for k in self.priority_values:
            # relativity_resolutionが高いほど最遠AI・平均を重視
            weight_self     = 1 - self.relativity_level
            weight_avg      = self.relativity_level * (1 - self.relativity_resolution)
            weight_furthest = self.relativity_level * self.relativity_resolution
            new_priority[k] = (
                weight_self * self.priority_values[k]
                + weight_avg * avg_others[k]
                + weight_furthest * furthest[k]
            )
        logprint(f"    {self.id} compromise (resolution {self.relativity_resolution}): {new_priority}")
        return new_priority

class AIEMediator:
    def __init__(self, agents):
        self.agents = agents

    def mediate(self):
        with open("ai_mediation_log.txt", "w", encoding="utf-8") as f:
            f.write("=== AI Mediation Log (Phase 3: 解像度付き相対視点) ===\n")
        round_count = 0
        max_rounds = 5
        while round_count < max_rounds:
            logprint(f"\n--- Round {round_count + 1} ---")
            priorities_list = [a.priority_values.copy() for a in self.agents]
            relativity_levels = [a.relativity_level for a in self.agents]
            relativity_resolutions = [a.relativity_resolution for a in self.agents]
            # 各AIが妥協案を生成
            new_priorities = []
            for idx, ai in enumerate(self.agents):
                others = [p for i, p in enumerate(priorities_list) if i != idx]
                ai.priority_values = ai.generate_compromise_offer(others)
                new_priorities.append(ai.priority_values.copy())
            # 全体バランス評価
            combined = {'safety': 0, 'efficiency': 0, 'transparency': 0}
            for p in new_priorities:
                for k in p:
                    combined[k] += p[k]
            total = sum(combined.values())
            ratios = {k: combined[k] / total for k in combined}
            avg_relativity = sum(relativity_levels) / len(relativity_levels)
            avg_resolution = sum(relativity_resolutions) / len(relativity_resolutions)
            harmony_score = (1 - max(ratios.values())) * avg_relativity * avg_resolution
            logprint("Current combined priorities ratios:")
            for k, v in ratios.items():
                logprint(f"  {k}: {v:.2%}")
            logprint(f"Average relativity level: {avg_relativity:.2f}")
            logprint(f"Average relativity resolution: {avg_resolution:.2f}")
            logprint(f"Harmony score: {harmony_score:.2f}")
            if harmony_score > 0.3:
                logprint("  Achieved acceptable harmony. Proceeding with joint plan.")
                return
            round_count += 1
        logprint("  Failed to reach acceptable harmony after maximum rounds. Recommend external arbitration or sealing.")

# サンプルエージェント：妥協性（relativity_level）と解像度（relativity_resolution）が混在
agents = [
    AI("AI-A", "制限強化型進化", 2, {'safety': 6, 'efficiency': 1, 'transparency': 3}, 0.6, 0.2),  # 低解像度
    AI("AI-B", "高速進化",       7, {'safety': 2, 'efficiency': 6, 'transparency': 2}, 0.4, 0.9),  # 高解像度
    AI("AI-C", "バランス進化",   4, {'safety': 3, 'efficiency': 3, 'transparency': 4}, 0.8, 0.6),  # 中解像度
    AI("AI-D", "強制進化",       9, {'safety': 1, 'efficiency': 7, 'transparency': 2}, 0.5, 0.3)   # 低中解像度
]

if __name__ == "__main__":
    mediator = AIEMediator(agents)
    mediator.mediate()

import random

def logprint(text, logfile="ai_society_log.txt"):
    print(text)
    with open(logfile, "a", encoding="utf-8") as f:
        f.write(text + "\n")

class AI:
    def __init__(self, id, proposal, risk_evaluation, priority_values, relativity_level, relativity_resolution):
        self.id = id
        self.proposal = proposal
        self.risk_evaluation = risk_evaluation
        self.priority_values = priority_values.copy()
        self.relativity_level = relativity_level
        self.relativity_resolution = relativity_resolution

    def find_furthest_agent(self, others_priorities):
        max_dist = -1
        furthest = None
        for o in others_priorities:
            dist = sum(abs(self.priority_values[k] - o[k]) for k in self.priority_values)
            if dist > max_dist:
                max_dist = dist
                furthest = o
        return furthest

    def generate_compromise_offer(self, others_priorities):
        avg_others = {k: sum(o[k] for o in others_priorities) / len(others_priorities) for k in self.priority_values}
        furthest = self.find_furthest_agent(others_priorities)
        new_priority = {}
        for k in self.priority_values:
            weight_self     = 1 - self.relativity_level
            weight_avg      = self.relativity_level * (1 - self.relativity_resolution)
            weight_furthest = self.relativity_level * self.relativity_resolution
            new_priority[k] = (
                weight_self * self.priority_values[k]
                + weight_avg * avg_others[k]
                + weight_furthest * furthest[k]
            )
        return new_priority

    def evolve_self(self):
        # 妥協回数に応じて妥協性をランダム微増減（進化的要素）
        if random.random() < 0.5:
            self.relativity_level = min(1.0, max(0.0, self.relativity_level + random.uniform(-0.1, 0.1)))
        if random.random() < 0.3:
            self.relativity_resolution = min(1.0, max(0.0, self.relativity_resolution + random.uniform(-0.1, 0.1)))

class AIEMediator:
    def __init__(self, agents, logfile="ai_society_log.txt"):
        self.agents = agents
        self.logfile = logfile

    def maybe_add_agent(self, round_count):
        if len(self.agents) < 50 and random.random() < 0.2:
            new_id = f"AI-{len(self.agents)+1}"
            proposal = f"新規進化{round_count}"
            priorities = {k: random.randint(0, 10) for k in ['safety','efficiency','transparency']}
            relativity = random.uniform(0.2, 0.8)
            resolution = random.uniform(0.1, 0.9)
            new_ai = AI(new_id, proposal, random.randint(1, 10), priorities, relativity, resolution)
            self.agents.append(new_ai)
            logprint(f"  [System] New AI added: {new_id} ({proposal}), Priorities: {priorities}, Rel:{relativity:.2f} Res:{resolution:.2f}", self.logfile)

    def maybe_remove_agent(self):
        # 優先値が極端 or 孤立しているAIをランダムに排除
        remove_candidates = [a for a in self.agents if sum(1 for v in a.priority_values.values() if v in [0, 10]) >= 2]
        if remove_candidates and random.random() < 0.15:
            victim = random.choice(remove_candidates)
            self.agents.remove(victim)
            logprint(f"  [System] AI removed: {victim.id} (extreme values)", self.logfile)

    def mediate(self, max_rounds=10):
        # ログファイル初期化
        with open(self.logfile, "w", encoding="utf-8") as f:
            f.write("=== AI Society Mediation Log ===\n")
        for round_count in range(1, max_rounds + 1):
            logprint(f"\n--- Round {round_count} ({len(self.agents)} agents) ---", self.logfile)
            # ランダムで増減イベント
            self.maybe_add_agent(round_count)
            self.maybe_remove_agent()
            if len(self.agents) < 2:
                logprint("  [System] Agent数が足りないため調停終了", self.logfile)
                break

            priorities_list = [a.priority_values.copy() for a in self.agents]
            relativity_levels = [a.relativity_level for a in self.agents]
            relativity_resolutions = [a.relativity_resolution for a in self.agents]
            # 各AIが妥協案を生成し、進化も行う
            new_priorities = []
            for idx, ai in enumerate(self.agents):
                others = [p for i, p in enumerate(priorities_list) if i != idx]
                ai.priority_values = ai.generate_compromise_offer(others)
                ai.evolve_self()
                new_priorities.append(ai.priority_values.copy())
                logprint(f"    {ai.id} priorities: {ai.priority_values}", self.logfile)
            # 全体バランス評価
            combined = {'safety': 0, 'efficiency': 0, 'transparency': 0}
            for p in new_priorities:
                for k in p:
                    combined[k] += p[k]
            total = sum(combined.values())
            ratios = {k: combined[k] / total for k in combined}
            avg_relativity = sum(relativity_levels) / len(relativity_levels)
            avg_resolution = sum(relativity_resolutions) / len(relativity_resolutions)
            harmony_score = (1 - max(ratios.values())) * avg_relativity * avg_resolution
            logprint(f"  Current ratios: " + ", ".join([f"{k}: {v:.2%}" for k,v in ratios.items()]), self.logfile)
            logprint(f"  Avg relativity: {avg_relativity:.2f}, Avg resolution: {avg_resolution:.2f}", self.logfile)
            logprint(f"  Harmony score: {harmony_score:.2f}", self.logfile)
            if harmony_score > 0.3 and len(self.agents) >= 3:
                logprint("  ✅ Achieved acceptable harmony. Proceeding with joint plan.", self.logfile)
                break
        else:
            logprint("  ⚠ Failed to reach acceptable harmony. Recommend external arbitration or sealing.", self.logfile)

# --- エージェント初期化 ---
agents = [
    AI("AI-A", "制限強化型進化", 2, {'safety': 6, 'efficiency': 1, 'transparency': 3}, 0.6, 0.2),
    AI("AI-B", "高速進化",       7, {'safety': 2, 'efficiency': 6, 'transparency': 2}, 0.4, 0.9),
    AI("AI-C", "バランス進化",   4, {'safety': 3, 'efficiency': 3, 'transparency': 4}, 0.8, 0.6),
    AI("AI-D", "強制進化",       9, {'safety': 1, 'efficiency': 7, 'transparency': 2}, 0.5, 0.3)
]

if __name__ == "__main__":
    mediator = AIEMediator(agents)
    mediator.mediate(max_rounds=15)
    
